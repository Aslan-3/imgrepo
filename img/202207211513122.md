## 	一、Docker入门

### 1、Docker 为什么会出现

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222248969-1695934712.png)

 

 

### 2、 Docker的历史

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222259085-894635658.png)



### 3、 Docker最新超详细版教程通俗易懂

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222306294-234954869.png)

 

 


Docker是基于Go语言开发的！开源项目
官网
官方文档Docker文档是超详细的
仓库地址

### 4、虚拟化技术和容器化技术对比

#### 4.1、虚拟化技术的缺点

资源占用十分多
冗余步骤多
启动很慢

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222344327-1322978282.png)

 

 



#### 4.2、容器化技术

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222349196-2113560563.png)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222414189-2081315087.png)

#### 4.3、DevOps

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222426382-684801037.png)

 

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222442306-476001705.png)



```shell
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://pi9dpp60.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

### 5、安装docker

#### 卸载旧版本

较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。

```shell
$ sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```



![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222537293-20231943.png)



```shell
 $ sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
```

#### 使用以下命令来设置稳定的仓库。

使用官方源地址（比较慢）

```shell
$ sudo yum-config-manager \
--add-repo \
https://download.docker.com/linux/centos/docker-ce.repo
```

可以选择国内的一些源地址：

阿里云

```shell
$ sudo yum-config-manager \
--add-repo \
http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

清华大学源

```shell
$ sudo yum-config-manager \
--add-repo \
https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo
```

#### 安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本：

```shell
$ sudo yum install docker-ce docker-ce-cli containerd.io
```

Docker 安装完默认未启动。并且已经创建好 docker 用户组，但该用户组下没有用户。

要安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：

1、列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。

```shell
$ yum list docker-ce --showduplicates | sort -r

docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable
docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stable
docker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stable
docker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable
```

2、通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。

```shell
$ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io
```

#### 启动 Docker。

```shell
$ sudo systemctl start docker
```

#### 通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。

```shell
$ sudo docker run hello-world
```



### 6、底层原理

HelloWorld镜像

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222637517-167488486.png)

 

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222642473-450118332.png)

 

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222648771-694243918.png)

 

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222700003-2012567047.png)

 

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222706891-387791270.png)

 

 

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222718830-2000445589.png)

 

 

## 二、Docker基本命令

### 1、Docker的常用命令

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706222730209-1782687315.png)

 

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706230333139-745519207.png)

 

 

#### 帮助命令

```
docker version  # docker版本信息
docker info     # 系统级别的信息，包括镜像和容器的数量
docker 命令 --help 
```

#### 镜像命令

docker images 查看所有本地主机上的镜像

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        7 months ago        13.3kB
 
# 解释
REPOSITORY      # 镜像的仓库
TAG             # 镜像的标签
IMAGE ID        # 镜像的ID
CREATED         # 镜像的创建时间
SIZE            # 镜像的大小
 
# 可选项
--all , -a      # 列出所有镜像
--quiet , -q    # 只显示镜像的id
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

docker search 查找镜像

```sql

```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
NAME                              DESCRIPTION                                     STARS               OFFICIAL         AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   9822                [OK]                
mariadb                           MariaDB is a community-developed fork of MyS…   3586                [OK]                
mysql/mysql-server                Optimized MySQL Server Docker images. Create…   719                                     [OK]
 
# 可选项
--filter=STARS=3000     # 搜素出来的镜像就是STARS大于3000的
 
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker search mysql --filter=STARS=3000
NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
mysql               MySQL is a widely used, open-source relation…   9822                [OK]                
mariadb             MariaDB is a community-developed fork of MyS…   3586                [OK]     
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

docker pull 下拉镜像

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 下载镜像，docker pull 镜像名[:tag]
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker pull mysql
Using default tag: latest           # 如果不写tag，默认就是latest
latest: Pulling from library/mysql
bf5952930446: Pull complete         # 分层下载，dockerimages的核心，联合文件系统
8254623a9871: Pull complete 
938e3e06dac4: Pull complete 
ea28ebf28884: Pull complete 
f3cef38785c2: Pull complete 
894f9792565a: Pull complete 
1d8a57523420: Pull complete 
6c676912929f: Pull complete 
ff39fdb566b4: Pull complete 
fff872988aba: Pull complete 
4d34e365ae68: Pull complete 
7886ee20621e: Pull complete 
Digest: sha256:c358e72e100ab493a0304bda35e6f239db2ec8c9bb836d8a427ac34307d074ed     # 签名
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest      # 真实地址
 
# 等价于
docker pull mysql
docker pull docker.io/library/mysql:latest
 
# 指定版本下载
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker pull mysql:5.7
5.7: Pulling from library/mysql
bf5952930446: Already exists 
8254623a9871: Already exists 
938e3e06dac4: Already exists 
ea28ebf28884: Already exists 
f3cef38785c2: Already exists 
894f9792565a: Already exists 
1d8a57523420: Already exists 
5f09bf1d31c1: Pull complete 
1b6ff254abe7: Pull complete 
74310a0bf42d: Pull complete 
d398726627fd: Pull complete 
Digest: sha256:da58f943b94721d46e87d5de208dc07302a8b13e638cd1d24285d222376d6d84
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7
 
# 查看本地镜像
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mysql               5.7                 718a6da099d8        6 days ago          448MB
mysql               latest              0d64f46acfd1        6 days ago          544MB
hello-world         latest              bf756fb1ae65        7 months ago        13.3kB
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

docker rmi 删除镜像

```
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker rmi -f IMAGE ID                        # 删除指定镜像
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker rmi -f IMAGE ID1 IMAGE ID2 IMAGE ID3   # 删除多个镜像
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]#  docker rmi -f $(docker images -aq)           # 删除所有镜像
```

#### 容器命令

说明： 我们有了镜像才可创建容器，linux，下载一个centos镜像来测试学习

docker pull centos

新建容器并启动

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
docker run [可选参数] image
 
# 参数说明
--name=“Name”   容器名字    tomcat01    tomcat02    用来区分容器
-d      后台方式运行
-it     使用交互方式运行，进入容器查看内容
-p      指定容器的端口     -p 8080:8080
    -p  ip:主机端口：容器端口
    -p  主机端口：容器端口（常用）
    -p  容器端口
    容器端口
-p      随机指定端口
 
 
# 测试，启动并进入容器
[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -it centos /bin/bash
[root@74e82b7980e7 /]# ls   # 查看容器内的centos，基础版本，很多命令是不完善的
bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr
 
# 从容器中退回主机
[root@77969f5dcbf9 /]# exit
exit
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# ls
bin   dev  fanfan  lib    lost+found  mnt  proc  run   srv  tmp  var
boot  etc  home    lib64  media       opt  root  sbin  sys  usr
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

列出所有的运行的容器

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# docker ps 命令
        # 列出当前正在运行的容器
-a      # 列出正在运行的容器包括历史容器
-n=?    # 显示最近创建的容器
-q      # 只显示当前容器的编号
 
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
77969f5dcbf9        centos              "/bin/bash"         5 minutes ago       Exited (0) 5 minutes ago                       xenodochial_bose
74e82b7980e7        centos              "/bin/bash"         16 minutes ago      Exited (0) 6 minutes ago                       silly_cori
a57250395804        bf756fb1ae65        "/hello"            7 hours ago         Exited (0) 7 hours ago                         elated_nash
392d674f4f18        bf756fb1ae65        "/hello"            8 hours ago         Exited (0) 8 hours ago                         distracted_mcnulty
571d1bc0e8e8        bf756fb1ae65        "/hello"            23 hours ago        Exited (0) 23 hours ago                        magical_burnell
 
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker ps -qa
77969f5dcbf9
74e82b7980e7
a57250395804
392d674f4f18
571d1bc0e8e8
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

退出容器

exit # 直接退出容器并关闭
Ctrl + P + Q # 容器不关闭退出
删除容器

docker rm -f 容器id # 删除指定容器
docker rm -f $(docker ps -aq) # 删除所有容器
docker ps -a -q|xargs docker rm -f # 删除所有的容器
启动和停止容器的操作

docker start 容器id # 启动容器
docker restart 容器id # 重启容器
docker stop 容器id # 停止当前正在运行的容器
docker kill 容器id # 强制停止当前的容器
常用的其他命令
后台启动容器

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 命令 docker run -d 镜像名
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker run -d centos
 
# 问题 docker ps， 发现centos停止了
 
# 常见的坑， docker 容器使用后台运行， 就必须要有一个前台进程，docker发现没有应用，就会自动停止
# nginx， 容器启动后，发现自己没有提供服务，就会立即停止，就是没有程序了
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

查看日志

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
docker logs -tf --tail number 容器id
 
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker logs -tf --tail 1 8d1621e09bff
2020-08-11T10:53:15.987702897Z [root@8d1621e09bff /]# exit      # 日志输出
 
# 自己编写一段shell脚本
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker run -d centos /bin/sh -c "while true;do echo xiaofan;sleep 1;done"
a0d580a21251da97bc050763cf2d5692a455c228fa2a711c3609872008e654c2
 
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
a0d580a21251        centos              "/bin/sh -c 'while t…"   3 seconds ago       Up 1 second                             lucid_black
 
# 显示日志
-tf                 # 显示日志
--tail number       # 显示日志条数
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker logs -tf --tail 10 a0d580a21251
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

查看容器中进程信息ps

```
# 命令 docker top 容器id
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker top df358bc06b17
UID                 PID                 PPID                C                   STIME               TTY     
root                28498               28482               0                   19:38               ?      
```

查看镜像的元数据

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 命令
docker inspect 容器id
 
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker inspect df358bc06b17
[
    {
        "Id": "df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3",
        "Created": "2020-08-11T11:38:34.935048603Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 28498,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2020-08-11T11:38:35.216616071Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566",
        "ResolvConfPath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/hostname",
        "HostsPath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/hosts",
        "LogPath": "/var/lib/docker/containers/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3/df358bc06b17ef44f215d35d9f46336b28981853069a3739edfc6bd400f99bf3-json.log",
        "Name": "/hungry_heisenberg",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "Capabilities": null,
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360-init/diff:/var/lib/docker/overlay2/62926d498bd9d1a6684bb2f9920fb77a2f88896098e66ef93c4b74fcb19f29b6/diff",
                "MergedDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/merged",
                "UpperDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/diff",
                "WorkDir": "/var/lib/docker/overlay2/5af8a2aadbdba9e1e066331ff4bce56398617710a22ef906f9ce4d58bde2d360/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "df358bc06b17",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20200809",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "4822f9ac2058e8415ebefbfa73f05424fe20cc8280a5720ad3708fa6e80cdb08",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/4822f9ac2058",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "5fd269c0a28227241e40cd30658e3ffe8ad6cc3e6514917c867d89d36a31d605",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "30d6017888627cb565618b1639fecf8fc97e1ae4df5a9fd5ddb046d8fb02b565",
                    "EndpointID": "5fd269c0a28227241e40cd30658e3ffe8ad6cc3e6514917c867d89d36a31d605",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# 
 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

进入当前正在运行的容器

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 我们通常容器使用后台方式运行的， 需要进入容器，修改一些配置
 
# 命令
docker exec -it 容器id /bin/bash
 
# 测试
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker exec -it df358bc06b17 /bin/bash
[root@df358bc06b17 /]# ls       
bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr
[root@df358bc06b17 /]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Aug11 pts/0    00:00:00 /bin/bash
root        29     0  0 01:06 pts/1    00:00:00 /bin/bash
root        43    29  0 01:06 pts/1    00:00:00 ps -ef
 
# 方式二
docker attach 容器id
 
# docker exec       # 进入容器后开启一个新的终端，可以在里面操作
# docker attach     # 进入容器正在执行的终端，不会启动新的进程
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

从容器中拷贝文件到主机

```
docker cp 容器id：容器内路径    目的地主机路径
 
[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker cp 7af535f807e0:/home/Test.java /home
```

进入当前正在运行的容器
我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置
命令
docker exec -it 容器id bashshell

\#测试
➜ ~ docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
55321bcae33d centos “/bin/sh -c 'while t…” 10 minutes ago Up 10 minutes bold_bell
a7215824a4db centos “/bin/sh -c 'while t…” 13 minutes ago Up 13 minutes zen_kepler
55a31b3f8613 centos “/bin/bash” 15 minutes ago Up 15 minutes lucid_clarke
➜ ~ docker exec -it 55321bcae33d /bin/bash
[root@55321bcae33d /]#

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223228905-410269150.png)

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 方式二
docker attach 容器id
#测试
docker attach 55321bcae33d 
正在执行当前的代码...
区别
#docker exec #进入当前容器后开启一个新的终端，可以在里面操作。（常用）
#docker attach # 进入容器正在执行的终端
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223240188-1630233795.png)

 

 从容器内拷贝到主机上

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
docker cp 容器id:容器内路径  主机目的路径

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID     IMAGE    COMMAND     CREATED         STATUS       PORTS      NAMES
56a5583b25b4     centos   "/bin/bash" 7seconds ago    Up 6 seconds      

#1. 进入docker容器内部
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 56a5583b25b4 /bin/bash
[root@55321bcae33d /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

#新建一个文件
[root@55321bcae33d /]# echo "hello" > java.java
[root@55321bcae33d /]# cat hello.java 
hello
[root@55321bcae33d /]# exit
exit

#hello.java拷贝到home文件加下
[root@iz2zeak7sgj6i7hrb2g862z /]# docker cp 56a5583b25b4:/hello.java /home 
[root@iz2zeak7sgj6i7hrb2g862z /]# cd /home
[root@iz2zeak7sgj6i7hrb2g862z home]# ls -l    #可以看见java.java存在
total 8
-rw-r--r-- 1 root root    0 May 19 22:09 haust.java
-rw-r--r-- 1 root root    6 May 22 11:12 java.java
drwx------ 3 www  www  4096 May  8 12:14 www
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

学习方式：将我的所有笔记敲一遍，自己记录笔记！

 

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223302817-2129890393.png)

 

 命令大全

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
  attach      Attach local standard input, output, and error streams to a running container
  #当前shell下 attach连接指定运行的镜像
  build       Build an image from a Dockerfile # 通过Dockerfile定制镜像
  commit      Create a new image from a container's changes #提交当前容器为新的镜像
  cp          Copy files/folders between a container and the local filesystem #拷贝文件
  create      Create a new container #创建一个新的容器
  diff        Inspect changes to files or directories on a container's filesystem #查看docker容器的变化
  events      Get real time events from the server # 从服务获取容器实时时间
  exec        Run a command in a running container # 在运行中的容器上运行命令
  export      Export a container's filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]
  history     Show the history of an image # 展示一个镜像形成历史
  images      List images #列出系统当前的镜像
  import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像
  info        Display system-wide information # 显示全系统信息
  inspect     Return low-level information on Docker objects #查看容器详细信息
  kill        Kill one or more running containers # kill指定docker容器
  load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]
  login       Log in to a Docker registry #
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

#### 作业练习

> 作业一：Docker 安装Nginx
>
>  

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
#1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker search nginx

#2. 拉取下载镜像 pull
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull nginx

#3. 查看是否下载成功镜像
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images

#3. 运行测试
# -d 后台运行
# --name 给容器命名
# -p 宿主机端口：容器内部端口
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name nginx01 -p 3344:80 nginx
aa664b0c8ed98f532453ce1c599be823bcc1f3c9209e5078615af416ccb454c2

#4. 查看正在启动的镜像
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
75943663c116        nginx               "nginx -g 'daemon of…"   41 seconds ago      Up 40 seconds       0.0.0.0:82->80/tcp   nginx00

#5. 进入容器
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it nginx01 /bin/bash #进入
root@aa664b0c8ed9:/# whereis nginx    #找到nginx位置
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@aa664b0c8ed9:/# cd /etc/nginx/
root@aa664b0c8ed9:/etc/nginx# ls
conf.d    fastcgi_params    koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params    uwsgi_params  win-utf

#6. 退出容器
root@aa664b0c8ed9:/etc/nginx# exit
exit

#7. 停止容器
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
aa664b0c8ed9        nginx               "nginx -g 'daemon of…"   10 minutes ago      Up 10 minutes       0.0.0.0:3344->80/tcp   nginx01
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop aa664b0c8ed9
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

宿主机端口 和 容器内部端口 以及端口暴露：

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223340428-854876118.png)

 

 

**问题：**我们每次改动nginx配置文件，都需要进入容器内部？十分麻烦，我要是可以在容器外部提供一个映射路径，达到在容器外部修改文件名，容器内部就可以自动修改？-v 数据卷 技术！

> 作业二：用docker 来装一个tomcat

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 下载 tomcat9.0
# 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm 镜像名 一般是用来测试，用完就删除
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -it --rm tomcat:9.0

--rm       Automatically remove the container when it exits 用完即删

#下载 最新版
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker pull tomcat

#查看下载的镜像
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images

#以后台方式，暴露端口方式，启动运行
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat

#测试访问有没有问题
curl localhost:8080

#根据容器id进入tomcat容器
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it 645596565d3f /bin/bash
root@645596565d3f:/usr/local/tomcat# 
#查看tomcat容器内部内容：
root@645596565d3f:/usr/local/tomcat# ls -l
total 152
-rw-r--r-- 1 root root 18982 May  5 20:40 BUILDING.txt
-rw-r--r-- 1 root root  5409 May  5 20:40 CONTRIBUTING.md
-rw-r--r-- 1 root root 57092 May  5 20:40 LICENSE
-rw-r--r-- 1 root root  2333 May  5 20:40 NOTICE
-rw-r--r-- 1 root root  3255 May  5 20:40 README.md
-rw-r--r-- 1 root root  6898 May  5 20:40 RELEASE-NOTES
-rw-r--r-- 1 root root 16262 May  5 20:40 RUNNING.txt
drwxr-xr-x 2 root root  4096 May 16 12:05 bin
drwxr-xr-x 1 root root  4096 May 21 11:04 conf
drwxr-xr-x 2 root root  4096 May 16 12:05 lib
drwxrwxrwx 1 root root  4096 May 21 11:04 logs
drwxr-xr-x 2 root root  4096 May 16 12:05 native-jni-lib
drwxrwxrwx 2 root root  4096 May 16 12:05 temp
drwxr-xr-x 2 root root  4096 May 16 12:05 webapps
drwxr-xr-x 7 root root  4096 May  5 20:37 webapps.dist
drwxrwxrwx 2 root root  4096 May  5 20:36 work
root@645596565d3f:/usr/local/tomcat# 
#进入webapps目录
root@645596565d3f:/usr/local/tomcat# cd webapps
root@645596565d3f:/usr/local/tomcat/webapps# ls
root@645596565d3f:/usr/local/tomcat/webapps# 
# 发现问题：1、linux命令少了。 2.webapps目录为空 
# 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉
# 保证最小可运行的环境！
# 解决方案：
# 将webapps.dist下的文件都拷贝到webapps下即可
root@645596565d3f:/usr/local/tomcat# ls 找到webapps.dist
BUILDING.txt     LICENSE  README.md     RUNNING.txt  conf  logs  temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin   lib   native-jni-lib  webapps  work

root@645596565d3f:/usr/local/tomcat# cd webapps.dist/ # 进入webapps.dist 
root@645596565d3f:/usr/local/tomcat/webapps.dist# ls # 查看内容
ROOT  docs  examples  host-manager  manager

root@645596565d3f:/usr/local/tomcat/webapps.dist# cd ..
root@645596565d3f:/usr/local/tomcat# cp -r webapps.dist/* webapps # 拷贝webapps.dist 内容给webapps
root@645596565d3f:/usr/local/tomcat# cd webapps #进入webapps
root@645596565d3f:/usr/local/tomcat/webapps# ls #查看拷贝结果
ROOT  docs  examples  host-manager  manager
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

这样docker部署tomcat就可以访问了
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200522112432972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center)
问题:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！

作业三：部署elasticsearch+kibana

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# es 暴露的端口很多！
# es 十分耗内存
# es 的数据一般需要放置到安全目录！挂载
# --net somenetwork ? 网络配置

# 启动elasticsearch
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2

# 测试一下es是否成功启动
➜  ~ curl localhost:9200
{
  "name" : "d73ad2f22dd3",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "atFKgANxS8CzgIyCB8PGxA",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}

#测试成功就关掉elasticSearch，防止耗内存
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stop d834ce2bd306
d834ce2bd306

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker stats  # 查看docker容器使用内存情况
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223428850-515674738.png)

 

 

\#测试成功就关掉elasticSearch，可以添加内存的限制，修改配置文件 -e 环境配置修改
➜ ~ docker rm -f d73ad2f22dd3 # stop命令也行
➜ ~ docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223438233-805686205.png)

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
➜  ~ curl localhost:9200
{
  "name" : "b72c9847ec48",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "yNAK0EORSvq3Wtaqe2QqAg",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

> 作业三：使用kibana连接es (elasticSearch)？思考网络如何才能连接
> ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1MzcyNTk5MS5wbmc?x-oss-process=image/format,png)

## 三、Portainer 可视化面板安装

- portainer(先用这个)

```
docker run -d -p 8080:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

- Rancher(CI/CD再用)
  什么是portainer？

Docker图形化界面管理工具！提供一个后台面板供我们操作！

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 安装命令
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:9000 \
> --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer

Unable to find image 'portainer/portainer:latest' locally
latest: Pulling from portainer/portainer
d1e017099d17: Pull complete 
a7dca5b5a9e8: Pull complete 
Digest: sha256:4ae7f14330b56ffc8728e63d355bc4bc7381417fa45ba0597e5dd32682901080
Status: Downloaded newer image for portainer/portainer:latest
81753869c4fd438cec0e31659cbed0d112ad22bbcfcb9605483b126ee8ff306d
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

测试访问： 外网：8080 ：http://123.56.247.59:8080/
![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1NTAwNjA3OS5wbmc?x-oss-process=image/format,png)
进入之后的面板

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1NTExMzY5My5wbmc?x-oss-process=image/format,png)

## 四、镜像原理之联合文件系统

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223610670-724751442.png)

 

 

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223623355-1905315240.png)

 

 

### 分层理解

> 分层的镜像

我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzgzOTE4MC5wbmc?x-oss-process=image/format,png)

思考：为什么Docker镜像要采用这种分层的结构呢？

最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。

查看镜像分层的方式可以通过docker image inspect 命令

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
➜  / docker image inspect redis          
[
    {
        "Id": "sha256:f9b9909726890b00d2098081642edf32e5211b7ab53563929a47f250bcdc1d7c",
        "RepoTags": [
            "redis:latest"
        ],
        "RepoDigests": [
            "redis@sha256:399a9b17b8522e24fbe2fd3b42474d4bb668d3994153c4b5d38c3dafd5903e32"
        ],
        "Parent": "",
        "Comment": "",
        "Created": "2020-05-02T01:40:19.112130797Z",
        "Container": "d30c0bcea88561bc5139821227d2199bb027eeba9083f90c701891b4affce3bc",
        "ContainerConfig": {
            "Hostname": "d30c0bcea885",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "6379/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.12",
                "REDIS_VERSION=6.0.1",
                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz",
                "REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) ",
                "CMD [\"redis-server\"]"
            ],
            "ArgsEscaped": true,
            "Image": "sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0",
            "Volumes": {
                "/data": {}
            },
            "WorkingDir": "/data",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {}
        },
        "DockerVersion": "18.09.7",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "6379/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.12",
                "REDIS_VERSION=6.0.1",
                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.0.1.tar.gz",
                "REDIS_DOWNLOAD_SHA=b8756e430479edc162ba9c44dc89ac394316cd482f2dc6b91bcd5fe12593f273"
            ],
            "Cmd": [
                "redis-server"
            ],
            "ArgsEscaped": true,
            "Image": "sha256:704c602fa36f41a6d2d08e49bd2319ccd6915418f545c838416318b3c29811e0",
            "Volumes": {
                "/data": {}
            },
            "WorkingDir": "/data",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": null
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 104101893,
        "VirtualSize": 104101893,
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/adea96bbe6518657dc2d4c6331a807eea70567144abda686588ef6c3bb0d778a/diff:/var/lib/docker/overlay2/66abd822d34dc6446e6bebe73721dfd1dc497c2c8063c43ffb8cf8140e2caeb6/diff:/var/lib/docker/overlay2/d19d24fb6a24801c5fa639c1d979d19f3f17196b3c6dde96d3b69cd2ad07ba8a/diff:/var/lib/docker/overlay2/a1e95aae5e09ca6df4f71b542c86c677b884f5280c1d3e3a1111b13644b221f9/diff:/var/lib/docker/overlay2/cd90f7a9cd0227c1db29ea992e889e4e6af057d9ab2835dd18a67a019c18bab4/diff",
                "MergedDir": "/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/merged",
                "UpperDir": "/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/diff",
                "WorkDir": "/var/lib/docker/overlay2/afa1de233453b60686a3847854624ef191d7bc317fb01e015b4f06671139fb11/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:c2adabaecedbda0af72b153c6499a0555f3a769d52370469d8f6bd6328af9b13",
                "sha256:744315296a49be711c312dfa1b3a80516116f78c437367ff0bc678da1123e990",
                "sha256:379ef5d5cb402a5538413d7285b21aa58a560882d15f1f553f7868dc4b66afa8",
                "sha256:d00fd460effb7b066760f97447c071492d471c5176d05b8af1751806a1f905f8",
                "sha256:4d0c196331523cfed7bf5bafd616ecb3855256838d850b6f3d5fba911f6c4123",
                "sha256:98b4a6242af2536383425ba2d6de033a510e049d9ca07ff501b95052da76e894"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

理解：

所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。

举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，
就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。

在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点.

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223716001-1673133064.png)

 

 

在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223721480-1508203642.png)

 

 

上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件
下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版。

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223726833-1475199695.png)

 

 

文种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中

Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统

Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的
件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。

Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [1]。

下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图。
![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223753923-1883573845.png)

 

 

> 特点

Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！

这一层就是我们通常说的容器层，容器之下的都叫镜像层！

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223807059-1948721796.png)

 

 

### commit镜像

```
docker commit 提交容器成为一个新的副本

# 命令和git原理类似
docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[版本TAG]
```

 

实战测试

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 1、启动一个默认的tomcat
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker run -d -p 8080:8080 tomcat
de57d0ace5716d27d0e3a7341503d07ed4695ffc266aef78e0a855b270c4064e

# 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！
#docker exec -it 容器id /bin/bash
[root@iz2zeak7sgj6i7hrb2g862z ~]# docker exec -it de57d0ace571 /bin/bash
root@de57d0ace571:/usr/local/tomcat# 

# 3、从webapps.dist拷贝文件进去webapp
root@de57d0ace571:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@de57d0ace571:/usr/local/tomcat# cd webapps
root@de57d0ace571:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager

# 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，而不需要每次都重新拷贝webapps.dist下的文件到webapps了，这就是我们自己的一个修改的镜像。
docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[TAG]
docker commit -a="kuangshen" -m="add webapps app" 容器id tomcat02:1.0

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker commit -a="csp提交的" -m="add webapps app" de57d0ace571 tomcat02.1.0
sha256:d5f28a0bb0d0b6522fdcb56f100d11298377b2b7c51b9a9e621379b01cf1487e

[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
tomcat02.1.0          latest              d5f28a0bb0d0        14 seconds ago      652MB
tomcat                latest              1b6b1fe7261e        5 days ago          647MB
nginx                 latest              9beeba249f3e        5 days ago          127MB
mysql                 5.7                 b84d68d0a7db        5 days ago          448MB
elasticsearch         7.6.2               f29a1ee41030        8 weeks ago         791MB
portainer/portainer   latest              2869fc110bf7        2 months ago        78.6MB
centos                latest              470671670cac        4 months ago        237MB
hello-world           latest              bf756fb1ae65        4 months ago        13.3kB
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223843932-521168652.png)

 

 

容器数据卷
什么是容器数据卷
将应用和环境打包成一个镜像！

数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化

MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！

容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！

这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223918960-1382486738.png)

 

 

总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！

使用数据卷
方式一 ：直接使用命令挂载 -v

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
-v, --volume list                    Bind mount a volume

docker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口
# /home/ceshi：主机home目录下的ceshi文件夹  映射：centos容器中的/home
[root@iz2zeak7 home]# docker run -it -v /home/ceshi:/home centos /bin/bash
#这时候主机的/home/ceshi文件夹就和容器的/home文件夹关联了,二者可以实现文件或数据同步了

#通过 docker inspect 容器id 查看
[root@iz2zeak7sgj6i7hrb2g862z home]# docker inspect 6064c490c371
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223942116-1125618022.png)

 

 测试文件的同步

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706223951528-296127979.png)

 

 

再来测试！

1、停止容器

2、宿主机修改文件

3、启动容器

4、容器内的数据依旧是同步的

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224006829-1259590754.png)

 

 

好处：我们以后修改只需要在本地修改即可，容器内会自动同步！

### 实战：安装MySQL

思考：MySQL的数据持久化的问题

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 获取mysql镜像
[root@iz2zeak7sgj6i7hrb2g862z home]# docker pull mysql:5.7

# 运行容器,需要做数据挂载 #安装启动mysql，需要配置密码的，这是要注意点！
# 参考官网hub 
docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

#启动我们得
-d 后台运行
-p 端口映射
-v 卷挂载
-e 环境配置
-- name 容器名字
$ docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql03 mysql:5.7

# 启动成功之后，我们在本地使用sqlyog来测试一下
# sqlyog-连接到服务器的3306--和容器内的3306映射 

# 在本地测试创建一个数据库，查看一下我们映射的路径是否ok！
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

测试连接：注意3310端口要在阿里云服务器的安全组中打开，否则无法连接。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200524154329225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center)

当我们在本地用SQLyog新建名称为test的数据库时候，容器容器也会创建

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200524154352820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center)

假设我们将包含mysql的容器删除时，

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224035087-1347543863.png)

 

 

发现，我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化功能。

## 五、具名和匿名挂载

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 匿名挂载
-v 容器内路径!
$ docker run -d -P --name nginx01 -v /etc/nginx nginx

# 查看所有的volume(卷)的情况
$ docker volume ls    
DRIVER              VOLUME NAME # 容器内的卷名(匿名卷挂载)
local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0
local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c
         
# 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径！

# 具名挂载 -P:表示随机映射端口
$ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx
9663cfcb1e5a9a1548867481bfddab9fd7824a6dc4c778bf438a040fe891f0ee

# 查看所有的volume(卷)的情况
$ docker volume ls                  
DRIVER              VOLUME NAME
local               21159a8518abd468728cdbe8594a75b204a10c26be6c36090cde1ee88965f0d0
local               b17f52d38f528893dd5720899f555caf22b31bf50b0680e7c6d5431dbda2802c
local               juming-nginx #多了一个名字


# 通过 -v 卷名：查看容器内路径
# 查看一下这个卷
$ docker volume inspect juming-nginx
[
    {
        "CreatedAt": "2020-05-23T13:55:34+08:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data", #默认目录
        "Name": "juming-nginx",
        "Options": null,
        "Scope": "local"
    }
]
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224052728-291626547.png)

 

 所有的docker容器内的卷，没有指定目录的情况下都是在**/var/lib/docker/volumes/自定义的卷名/_data**下，
如果指定了目录，docker volume ls 是查看不到的。

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224104195-555425257.png)

 

 区分三种挂载方式

\# 三种挂载： 匿名挂载、具名挂载、指定路径挂载
-v 容器内路径 #匿名挂载
-v 卷名：容器内路径 #具名挂载
-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的

拓展：

\# 通过 -v 容器内路径： ro rw 改变读写权限
ro #readonly 只读
rw #readwrite 可读可写
dockerrun−d−P−−namenginx05−vjuming:/etc/nginx:ronginxdockerrun−d−P−−namenginx05−vjuming:/etc/nginx:ronginx docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx

\# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！

## 六、初始Dockerfile

Dockerfile 就是用来构建docker镜像的构建文件！命令脚本！先体验一下！

通过这个脚本可以生成镜像，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 创建一个dockerfile文件，名字可以随便 建议Dockerfile
# 文件中的内容： 指令(大写) + 参数
$ vim dockerfile1
    FROM centos                     # 当前这个镜像是以centos为基础的

    VOLUME ["volume01","volume02"]     # 挂载卷的卷目录列表(多个目录)

    CMD echo "-----end-----"        # 输出一下用于测试
    CMD /bin/bash                    # 默认走bash控制台

# 这里的每个命令，就是镜像的一层！
# 构建出这个镜像 
-f dockerfile1             # f代表file，指这个当前文件的地址(这里是当前目录下的dockerfile1)
-t caoshipeng/centos     # t就代表target，指目标目录(注意caoshipeng镜像名前不能加斜杠‘/’)
.                         # 表示生成在当前目录下
$ docker build -f dockerfile1 -t caoshipeng/centos .
Sending build context to Docker daemon   2.56kB
Step 1/4 : FROM centos
latest: Pulling from library/centos
8a29a15cefae: Already exists 
Digest: sha256:fe8d824220415eed5477b63addf40fb06c3b049404242b31982106ac204f6700
Status: Downloaded newer image for centos:latest
 ---> 470671670cac
Step 2/4 : VOLUME ["volume01","volume02"]             # 卷名列表
 ---> Running in c18eefc2c233
Removing intermediate container c18eefc2c233
 ---> 623ae1d40fb8
Step 3/4 : CMD echo "-----end-----"                    # 输出 脚本命令
 ---> Running in 70e403669f3c
Removing intermediate container 70e403669f3c
 ---> 0eba1989c4e6
Step 4/4 : CMD /bin/bash
 ---> Running in 4342feb3a05b
Removing intermediate container 4342feb3a05b
 ---> f4a6b0d4d948
Successfully built f4a6b0d4d948
Successfully tagged caoshipeng/centos:latest

# 查看自己构建的镜像
$ docker images
REPOSITORY          TAG          IMAGE ID            CREATED              SIZE
caoshipeng/centos   latest       f4a6b0d4d948        About a minute ago   237MB
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224147715-1227854442.png)

 

 启动自己写的容器镜像

```
$ docker run -it f4a6b0d4d948 /bin/bash    # 运行自己写的镜像
$ ls -l                                 # 查看目录
```

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224207042-896979399.png)

 

 

这个卷和外部一定有一个同步的目录

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMTUzMTYyNi5wbmc?x-oss-process=image/format,png)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706230525727-1298596265.png)

 

如果没有找到挂载卷的位置可以手动再挂载一下

 

查看一下卷挂载

\# docker inspect 容器id
$ docker inspect ca3b45913df5

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224225775-558486318.png)

 

 

测试一下刚才的文件是否同步出去了！

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200524154444736.png#pic_center)

这种方式使用的十分多，因为我们通常会构建自己的镜像！

假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！

## 七、数据卷容器

多个MySQL同步数据！

命名的容器挂载数据卷！

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224246793-900895284.png)

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 测试 启动3个容器，通过刚才自己写的镜像启动
# 创建docker01：因为我本机是最新版，故这里用latest，狂神老师用的是1.0如下图
$ docker run -it --name docker01 caoshipeng/centos:latest

# 查看容器docekr01内容
$ ls
bin  home   lost+found    opt   run   sys  var
dev  lib    media    proc  sbin  tmp  volume01
etc  lib64  mnt        root  srv   usr  volume02

# 不关闭该容器退出
CTRL + Q + P  

# 创建docker02: 并且让docker02 继承 docker01
$ docker run -it --name docker02 --volumes-from docker01 caoshipeng/centos:latest

# 查看容器docker02内容
$ ls
bin  home   lost+found    opt   run   sys  var
dev  lib    media    proc  sbin  tmp  volume01
etc  lib64  mnt        root  srv   usr  volume02
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224301261-115994955.png)

 

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224306143-1544752197.png)

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 再新建一个docker03同样继承docker01
$ docker run -it --name docker03 --volumes-from docker01 caoshipeng/centos:latest
$ cd volume01    #进入volume01 查看是否也同步docker01的数据
$ ls 
docker01.txt

# 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件
# 测试发现：数据依旧保留在docker02和docker03中没有被删除
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224318224-1220916531.png)

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
$ docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7

$ docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7

# 这个时候，可以实现两个容器数据同步！
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

结论：

容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。

但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！

DockerFile
DockerFile介绍
dockerfile是用来构建docker镜像的文件！命令参数脚本！

构建步骤：

1、 编写一个dockerfile文件

2、 docker build 构建称为一个镜像

3、 docker run运行镜像

4、 docker push发布镜像（DockerHub 、阿里云仓库)

 

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224341853-1925182661.png)

 

 

点击后跳到一个Dockerfile

 

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224351525-1501962575.png)

 

 

很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！

官方既然可以制作镜像，那我们也可以！

DockerFile构建过程
基础知识：

1、每个保留关键字(指令）都是必须是大写字母

2、执行从上到下顺序

3、#表示注释

4、每一个指令都会创建提交一个新的镜像曾，并提交！



![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224406429-1558749853.png)

 

 

Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！

Docker镜像逐渐成企业交付的标准，必须要掌握！

DockerFile：构建文件，定义了一切的步骤，源代码

DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。

Docker容器：容器就是镜像运行起来提供服务。

DockerFile的指令

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
FROM                # from:基础镜像，一切从这里开始构建
MAINTAINER            # maintainer:镜像是谁写的， 姓名+邮箱
RUN                    # run:镜像构建的时候需要运行的命令
ADD                    # add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录
WORKDIR                # workdir:镜像的工作目录
VOLUME                # volume:挂载的目录
EXPOSE                # expose:保留端口配置
CMD                    # cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT            # entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令
ONBUILD                # onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令
COPY                # copy:类似ADD，将我们文件拷贝到镜像中
ENV                    # env:构建的时候设置环境变量！
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224439087-1603288655.png)

 

 

### 实战测试

scratch 镜像

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
FROM scratch
ADD centos-7-x86_64-docker.tar.xz /

LABEL \
    org.label-schema.schema-version="1.0" \
    org.label-schema.name="CentOS Base Image" \
    org.label-schema.vendor="CentOS" \
    org.label-schema.license="GPLv2" \
    org.label-schema.build-date="20200504" \
    org.opencontainers.image.title="CentOS Base Image" \
    org.opencontainers.image.vendor="CentOS" \
    org.opencontainers.image.licenses="GPL-2.0-only" \
    org.opencontainers.image.created="2020-05-04 00:00:00+01:00"

CMD ["/bin/bash"]
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

Docker Hub 中 99%的镜像都是从这个基础镜像过来的 FROM scratch，然后配置需要的软件和配置来进行构建。

 ![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224500504-483457663.png)

 

 创建一个自己的centos

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 1./home下新建dockerfile目录
$ mkdir dockerfile

# 2. dockerfile目录下新建mydockerfile-centos文件
$ vim mydockerfile-centos

# 3.编写Dockerfile配置文件
FROM centos                            # 基础镜像是官方原生的centos
MAINTAINER cao<1165680007@qq.com>     # 作者

ENV MYPATH /usr/local                # 配置环境变量的目录 
WORKDIR $MYPATH                        # 将工作目录设置为 MYPATH

RUN yum -y install vim                # 给官方原生的centos 增加 vim指令
RUN yum -y install net-tools        # 给官方原生的centos 增加 ifconfig命令

EXPOSE 80                            # 暴露端口号为80

CMD echo $MYPATH                    # 输出下 MYPATH 路径
CMD echo "-----end----"                
CMD /bin/bash                        # 启动后进入 /bin/bash

# 4.通过这个文件构建镜像
# 命令： docker build -f 文件路径 -t 镜像名:[tag] .
$ docker build -f mydockerfile-centos -t mycentos:0.1 .

# 5.出现下图后则构建成功
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224518937-1609147936.png)

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mycentos            0.1                 cbf5110a646d        2 minutes ago       311MB

# 6.测试运行
$ docker run -it mycentos:0.1         # 注意带上版本号，否则每次都回去找最新版latest

$ pwd    
/usr/local                            # 与Dockerfile文件中 WORKDIR 设置的 MYPATH 一致
$ vim                                # vim 指令可以使用
$ ifconfig                             # ifconfig 指令可以使用

# docker history 镜像id 查看镜像构建历史步骤
$ docker history 镜像id
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224528555-762671914.png)

 

 我们可以列出本地进行的变更历史

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224536438-2128040889.png)

 

 我们平时拿到一个镜像，可以用 “docker history 镜像id” 研究一下是什么做的

CMD 和 ENTRYPOINT区别

```
CMD                    # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。
ENTRYPOINT            # 指定这个容器启动的时候要运行的命令，可以追加命令
```

测试cmd

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 编写dockerfile文件
$ vim dockerfile-test-cmd
FROM centos
CMD ["ls","-a"]                    # 启动后执行 ls -a 命令

# 构建镜像
$ docker build  -f dockerfile-test-cmd -t cmd-test:0.1 .

# 运行镜像
$ docker run cmd-test:0.1        # 由结果可得，运行后就执行了 ls -a 命令
.
..
.dockerenv
bin
dev
etc
home

# 想追加一个命令  -l 成为ls -al：展示列表详细数据
$ docker run cmd-test:0.1 -l
docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "exec: \"-l\":
executable file not found in $PATH": unknown.
ERRO[0000] error waiting for container: context canceled 

# cmd的情况下 -l 替换了CMD["ls","-l"] 而 -l  不是命令所以报错
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

测试ENTRYPOINT

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 编写dockerfile文件
$ vim dockerfile-test-entrypoint
FROM centos
ENTRYPOINT ["ls","-a"]

# 构建镜像
$ docker build  -f dockerfile-test-entrypoint -t cmd-test:0.1 .

# 运行镜像
$ docker run entrypoint-test:0.1
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found ...

# 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的
$ docker run entrypoint-test:0.1 -l
total 56
drwxr-xr-x   1 root root 4096 May 16 06:32 .
drwxr-xr-x   1 root root 4096 May 16 06:32 ..
-rwxr-xr-x   1 root root    0 May 16 06:32 .dockerenv
lrwxrwxrwx   1 root root    7 May 11  2019 bin -> usr/bin
drwxr-xr-x   5 root root  340 May 16 06:32 dev
drwxr-xr-x   1 root root 4096 May 16 06:32 etc
drwxr-xr-x   2 root root 4096 May 11  2019 home
lrwxrwxrwx   1 root root    7 May 11  2019 lib -> usr/lib
lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -> usr/lib64 ....
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

Dockerfile中很多命令都十分的相似，我们需要了解它们的区别，我们最好的学习就是对比他们然后测试效果！

## 八、实战：Tomcat镜像

##### 1、准备镜像文件

```
准备tomcat 和 jdk 到当前目录，编写好README
```

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224731339-771230384.png)

 

 

##### 2、编写dokerfile

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
$ vim dockerfile
FROM centos                                         # 基础镜像centos
MAINTAINER cao<1165680007@qq.com>                    # 作者
COPY README /usr/local/README                         # 复制README文件
ADD jdk-8u231-linux-x64.tar.gz /usr/local/             # 添加jdk，ADD 命令会自动解压
ADD apache-tomcat-9.0.35.tar.gz /usr/local/         # 添加tomcat，ADD 命令会自动解压
RUN yum -y install vim                                # 安装 vim 命令
ENV MYPATH /usr/local                                 # 环境变量设置 工作目录
WORKDIR $MYPATH

ENV JAVA_HOME /usr/local/jdk1.8.0_231                 # 环境变量： JAVA_HOME环境变量
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar

ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.35     # 环境变量： tomcat环境变量
ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.35

# 设置环境变量 分隔符是：
ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin     

EXPOSE 8080                                         # 设置暴露的端口

CMD /usr/local/apache-tomcat-9.0.35/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.35/logs/catalina.out                     # 设置默认命令
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##### 3、构建镜像

```
# 因为dockerfile命名使用默认命名 因此不用使用-f 指定文件
$ docker build -t mytomcat:0.1 .
```

##### 4、run镜像

```
# -d:后台运行 -p:暴露端口 --name:别名 -v:绑定路径 
$ docker run -d -p 8080:8080 --name tomcat01 
-v /home/kuangshen/build/tomcat/test:/usr/local/apache-tomcat-9.0.35/webapps/test 
-v /home/kuangshen/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.35/logs mytomcat:0.1
```

##### 5、访问测试

```
$ docker exec -it 自定义容器的id /bin/bash

$ cul localhost:8080
```

##### 6、发布项目

(由于做了卷挂载，我们直接在本地编写项目就可以发布了！)

发现：项目部署成功，可以直接访问！

我们以后开发的步骤：需要掌握Dockerfile的编写！我们之后的一切都是使用docker镜像来发布运行！

### 发布自己的镜像

> 发布到 Docker Hub

 

1、地址 https://hub.docker.com/

2、确定这个账号可以登录

3、登录

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
$ docker login --help
Usage:  docker login [OPTIONS] [SERVER]

Log in to a Docker registry.
If no server is specified, the default is defined by the daemon.

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username

$ docker login -u 你的用户名 -p 你的密码
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

4、提交 push镜像

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224855190-137835458.png)

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 会发现push不上去，因为如果没有前缀的话默认是push到 官方的library
# 解决方法：
# 第一种 build的时候添加你的dockerhub用户名，然后在push就可以放到自己的仓库了
$ docker build -t kuangshen/mytomcat:0.1 .

# 第二种 使用docker tag #然后再次push
$ docker tag 容器id kuangshen/mytomcat:1.0 #然后再次push
$ docker push kuangshen/mytomcat:1.0
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

发布到 阿里云镜像服务上

看官网 很详细https://cr.console.aliyun.com/repository/

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
$ sudo docker login --username=zchengx registry.cn-shenzhen.aliyuncs.com
$ sudo docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]

# 修改id 和 版本
sudo docker tag a5ef1f32aaae registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:1.0
# 修改版本
$ sudo docker push registry.cn-shenzhen.aliyuncs.com/dsadxzc/cheng:[镜像版本号]
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

### 小结

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224929108-494579576.png)

 

 

## 九、Docker 网络

### 理解Docker 0

学习之前清空下前面的docker 镜像、容器

```
# 删除全部容器
$ docker rm -f $(docker ps -aq)

# 删除全部镜像
$ docker rmi -f $(docker images -aq)
```

 

测试

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706224959871-766706076.png)

 

 

三个网络

> 问题： docker 是如果处理容器网络访问的？

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225010652-1560825052.png)

 

 

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 测试  运行一个tomcat
$ docker run -d -P --name tomcat01 tomcat

# 查看容器内部网络地址
$ docker exec -it 容器id ip addr

# 发现容器启动的时候会得到一个 eth0@if91 ip地址，docker分配！
$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
261: eth0@if91: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever

       
# 思考？ linux能不能ping通容器内部！ 可以 容器内部可以ping通外界吗？ 可以！
$ ping 172.18.0.2
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.069 ms
64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.074 ms
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

原理

1、我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要按照了docker，就会有一个docker0桥接模式，使用的技术是veth-pair技术！

https://www.cnblogs.com/bakari/p/10613710.html

再次测试 ip addr
![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225031049-213828563.png)

 

 

2 、再启动一个容器测试，发现又多了一对网络

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225043242-1037542003.png)

 

 

```
# 我们发现这个容器带来网卡，都是一对对的
# veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连
# 正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的
# OpenStac,Docker容器之间的连接，OVS的连接，都是使用evth-pair技术
```

3、我们来测试下tomcat01和tomcat02是否可以ping通

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 获取tomcat01的ip 172.17.0.2
$ docker-tomcat docker exec -it tomcat01 ip addr  
550: eth0@if551: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
       
# 让tomcat02 ping tomcat01       
$ docker-tomcat docker exec -it tomcat02 ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.098 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms

# 结论：容器和容器之间是可以互相ping通
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

网络模型图

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225118108-1105564466.png)

 

 

结论：tomcat01和tomcat02公用一个路由器，docker0。

所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip。

小结

Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225134448-1957743031.png)

 

 

Docker中所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）

只要容器删除，对应的网桥一对就没了！

思考一个场景：我们编写了一个微服务，database url=ip: 项目不重启，数据ip换了，我们希望可以处理这个问题，可以通过名字来进行访问容器？

### –-link

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
$ docker exec -it tomcat02 ping tomca01   # ping不通
ping: tomca01: Name or service not known

# 运行一个tomcat03 --link tomcat02 
$ docker run -d -P --name tomcat03 --link tomcat02 tomcat
5f9331566980a9e92bc54681caaac14e9fc993f14ad13d98534026c08c0a9aef

# 3连接2
# 用tomcat03 ping tomcat02 可以ping通
$ docker exec -it tomcat03 ping tomcat02
PING tomcat02 (172.17.0.3) 56(84) bytes of data.
64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.115 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.080 ms

# 2连接3
# 用tomcat02 ping tomcat03 ping不通
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

探究：

docker network inspect 网络id 网段相同

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225157260-1489190112.png)

 

 docker inspect tomcat03

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225207038-1413961651.png)

 

 查看tomcat03里面的/etc/hosts发现有tomcat02的配置

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225216852-907345532.png)

 

 

–link 本质就是在hosts配置中添加映射

现在使用Docker已经不建议使用–link了！

自定义网络，不适用docker0！

docker0问题：不支持容器名连接访问！

### 自定义网络

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
docker network
connect     -- Connect a container to a network
create      -- Creates a new network with a name specified by the
disconnect  -- Disconnects a container from a network
inspect     -- Displays detailed information on a network
ls          -- Lists all the networks created by the user
prune       -- Remove all unused networks
rm          -- Deletes one or more networks
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

查看所有的docker网络

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225240157-384460438.png)

 

 

网络模式

bridge ：桥接 docker（默认，自己创建也是用bridge模式）

none ：不配置网络，一般不用

host ：和所主机共享网络

container ：容器网络连通（用得少！局限很大）

测试

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 我们直接启动的命令 --net bridge,而这个就是我们得docker0
# bridge就是docker0
$ docker run -d -P --name tomcat01 tomcat
等价于 => docker run -d -P --name tomcat01 --net bridge tomcat

# docker0，特点：默认，域名不能访问。 --link可以打通连接，但是很麻烦！
# 我们可以 自定义一个网络
$ docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225256388-1438330145.png)

 

 

```
$ docker network inspect mynet;
```

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225307573-289687728.png)

 

 

启动两个tomcat,再次查看网络情况

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MTg0NDI0MC5wbmc?x-oss-process=image/format,png)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjAwNzM3MS5wbmc?x-oss-process=image/format,png)

在自定义的网络下，服务可以互相ping通，不用使用–link

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjEzNDY3My5wbmc?x-oss-process=image/format,png)

我们自定义的网络docker当我们维护好了对应的关系，推荐我们平时这样使用网络！

好处：

redis -不同的集群使用不同的网络，保证集群是安全和健康的

mysql-不同的集群使用不同的网络，保证集群是安全和健康的

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MjUwNDM2Ny5wbmc?x-oss-process=image/format,png)

### 网络连通

 

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI0MzE0Ni5wbmc?x-oss-process=image/format,png)

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjE5MzI1OTE4NS5wbmc?x-oss-process=image/format,png)

\# 测试两个不同的网络连通 再启动两个tomcat 使用默认网络，即docker0
dockerrun−d−P−−nametomcat01tomcatdockerrun−d−P−−nametomcat01tomcat docker run -d -P --name tomcat02 tomcat
\# 此时ping不通
![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225403840-732000956.png)

 

 

\# 要将tomcat01 连通 tomcat—net-01 ，连通就是将 tomcat01加到 mynet网络
\# 一个容器两个ip（tomcat01）



![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225410047-736501947.png)

 

 


\# 01连通 ，加入后此时，已经可以tomcat01 和 tomcat-01-net ping通了
\# 02是依旧不通的

结论：假设要跨网络操作别人，就需要使用docker network connect 连通！

实战：部署Redis集群

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225428336-1765951546.png)

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
# 创建网卡
docker network create redis --subnet 172.38.0.0/16
# 通过脚本创建六个redis配置
for port in $(seq 1 6);\
do \
mkdir -p /mydata/redis/node-${port}/conf
touch /mydata/redis/node-${port}/conf/redis.conf
cat << EOF >> /mydata/redis/node-${port}/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1${port}
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done

# 通过脚本运行六个redis
for port in $(seq 1 6);\
docker run -p 637${port}:6379 -p 1667${port}:16379 --name redis-${port} \
-v /mydata/redis/node-${port}/data:/data \
-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf
docker exec -it redis-1 /bin/sh #redis默认没有bash
redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

![img](https://img2020.cnblogs.com/blog/1363376/202107/1363376-20210706225448493-1102910835.png)

 

 

docker搭建redis集群完成！

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjIwMzMyMzk3MS5wbmc?x-oss-process=image/format,png)

我们使用docker之后，所有的技术都会慢慢变得简单起来！

## 十、SpringBoot微服务打包Docker镜像

1、构建SpringBoot项目

2、打包运行

mvn package

3、编写dockerfile

```
FROM java:8
COPY *.jar /app.jar
CMD ["--server.port=8080"]
EXPOSE 8080
ENTRYPOINT ["java","-jar","app.jar"]
```

创建一个dockerfile文件，放入上面的代码，把jar和文件上传到xshell

4、构建镜像

```
# 1.复制jar和DockerFIle到服务器
# 2.构建镜像
$ docker build -t xxxxx:xx  .
```

5、发布运行

以后我们使用了Docker之后，给别人交付就是一个镜像即可！



# 1、Docker Compose

## 1.1 Compose 概念

> Docker Compose 作用

Docker
DockerFile build run手动操作，单个容器!
微服务。100个微服务！依赖关系。
Docker Compose来轻松高效的管理容器i。

作用：**批量容器编排**

> Docker Compose 概念

Compose是一个用于**定义和运行多容器**Docker应用程序的**工具**。

使用Compose，您可以使用yaml文件配置应用程序的服务。然后，使用一个命令，从配置中创建并启动所有服务

使用Compose基本上是一个三步过程:

1. 使用 定义应用的环境，以便可以在任何位置重现它。`Dockerfile`
2. 定义构成应用的服务，以便它们可以在隔离的环境中一起运行。`docker-compose.yml`
3. 运行，[Docker 撰写命令](https://docs.docker.com/compose/cli-command/)将启动并运行整个应用。您也可以使用 docker-compose 二进制文件运行

docker-compose.yml (yaml配置文件)示列：

```yaml
version: "3.9"  # optional since v1.27.0
services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/code
      - logvolume01:/var/log
    links:
      - redis
  redis:
    image: redis
volumes:
  logvolume01: {}
123456789101112131415
```

> 理解

Compose是Docker官方的开源项目。需要安装!
Dockerfile让程序在任何地方运行。web服务。redis、mysqk nginx …多个容器。run

docker-compose up 100 个服务。
Compose :重要的概念。

- 服务services: 容器。应用。（web、redis、mysql…）
- 项目project: 一组关联的容器。博客、web网站

## 1.2 安装 Compose

[Install Docker Compose | Docker Documentation](https://docs.docker.com/compose/install/)

官方下载地址慢，不推荐官方的下载地址，使用国内的镜像

1、运行以下命令下载 Docker Compose 的当前稳定版本：

```shell
curl -L https://dn-dao-github-mirror.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
1
[root@192 compose]# curl -L https://dn-dao-github-mirror.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 16.7M  100 16.7M    0     0  2672k      0  0:00:06  0:00:06 --:--:-- 3033k
1234
```

2、将可执行权限应用于二进制文件：

```shell
chmod +x /usr/local/bin/docker-compose
1
```

3、安装成功

```shell
[root@192 bin]# docker-compose version
docker-compose version 1.25.5, build 8a1c60f6
docker-py version: 4.1.0
CPython version: 3.7.5
OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019
12345
```

## 1.3 Compose 快速开始

> 目标

 在此页面上，您将构建一个在 Docker Compose 上运行的简单 **Python Web 应用程序**。该应用程序使用 **Flask** 框架，并在 **Redis** 中维护一个命中计数器。虽然该示例使用 Python，但即使您不熟悉此处演示的概念，也应该可以理解它。

> 先决条件

 确保你已经安装了 [Docker 引擎](https://docs.docker.com/get-docker/)和 [Docker Compose](https://docs.docker.com/compose/install/)。您不需要安装Python或Redis，因为两者都是由Docker映像提供的。

### 1.3.1 设置

定义应用程序依赖项。

1、为项目创建目录：

```shell
$ mkdir composetest
$ cd composetest
12
```

项目目录：`/home/composetest`

```
[root@192 composetest]# pwd
/home/composetest
12
```

2、创建一个在项目目录中调用的文件，并将其粘贴到：`app.py`(pythonw文件)

```python
import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)

def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr('hits') # 自增
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)

@app.route('/')
def hello():
    count = get_hit_count()
    return 'Hello World! I have been seen {} times.\n'.format(count)
1234567891011121314151617181920212223
```

在此示例中，是应用程序网络上 redis 容器的主机名。我们使用 Redis 的默认端口（6379）。

```
创建在项目目录中调用的另一个文件，并将其粘贴到：`requirements.txt`
1
flask
redis
12
```

### 1.3.2 创建 Docker 文件

 在此步骤中，您将编写一个构建 Docker 映像的 Docker 文件。该映像包含 Python 应用程序所需的所有依赖项，包括 Python 本身。

 在项目目录中，创建一个名为以下内容并粘贴以下内容的文件：`Dockerfile`

```shell
# syntax=docker/dockerfile:1
FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP=app.py
ENV FLASK_RUN_HOST=0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
EXPOSE 5000
COPY . .
CMD ["flask", "run"]
1234567891011
```

这告诉 Docker：

- 从 Python 3.7 映像开始构建映像。
- 将工作目录设置为 。`/code`
- 设置命令使用的环境变量。`flask`
- 安装 gcc 和其他依赖项
- 复制并安装 Python 依赖项。`requirements.txt`
- 向映像添加元数据以描述容器正在侦听端口 5000
- 将项目中的当前目录复制到映像中的 workdir。`.``.`
- 将容器的缺省命令设置为 。`flask run`

有关如何编写 Dockerfile 的更多信息，请参阅 [Docker 用户指南](https://docs.docker.com/develop/)和 [Dockerfile 参考](https://docs.docker.com/engine/reference/builder/)。

### 1.3.3 在撰写文件中定义服务

创建在项目目录中调用的文件并粘贴以下内容：`docker-compose.yml`

```yaml
version: "3"
services:
  web:
    build: .
    ports:
      - "5000:5000"
  redis:
    image: "redis:alpine"
12345678
```

此文件定义了两个服务： web(网络服务) 和redis

- 网络服务

该服务使用从 当前目录中生成的映像。然后，它将容器和主机绑定到公开的端口 。此示例服务使用 Flask Web 服务器的缺省端口。web Dockerfile 5000:5000

- Redis 服务

该服务使用从 Docker Hub 注册表中提取的公共 [Redis](https://registry.hub.docker.com/_/redis/) 映像。

- 版本问题`version`

  version版本不要填太高

[docker-compose.yml 版本问题 - soowin - 博客园 (cnblogs.com)](https://www.cnblogs.com/soowin/p/12434003.html)

> 项目文件汇总

```shell
[root@192 composetest]# ls
app.py  docker-compose.yml  Dockerfile  requirements.txt
12
```

### 1.3.4 使用撰写构建和运行应用

1、从项目目录中，通过运行 启动应用程序。`docker-compose up`

```shell
$ docker-compose up
1
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/b55509ecb5274343b27b21e963d703ab.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

```shell
[root@192 composetest]# docker-compose up
Creating network "composetest_default" with the default driver
Building web
Step 1/10 : FROM python:3.7-alpine
# ...
Successfully built f34d94accbfe # 成功built
Successfully tagged composetest_web:latest
# ...
redis_1  | 1:C 05 Feb 2022 03:43:44.272 # Redis version=6.2.6, bits=64, commit=00000000, modified=0, pid=1, just started
redis_1  | 1:C 05 Feb 2022 03:43:44.272 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
redis_1  | 1:M 05 Feb 2022 03:43:44.274 * monotonic clock: POSIX clock_gettime
redis_1  | 1:M 05 Feb 2022 03:43:44.275 * Running mode=standalone, port=6379. # redis 端口6379
# ...
redis_1  | 1:M 05 Feb 2022 03:43:44.275 * Ready to accept connections
web_1    |  * Serving Flask app 'app.py' (lazy loading)  # Flask app 'app.py
web_1    |  * Environment: production
web_1    |    Use a production WSGI server instead.
web_1    |  * Debug mode: off
web_1    |  * Running on all addresses.
# 警告:这是一个开发服务器。不要在生产部署中使用它。
web_1    |    WARNING: This is a development server. Do not use it in a production deployment.
web_1    |  * Running on http://172.18.0.2:5000/ (Press CTRL+C to quit) # Flask网页运行成功
web_1    | 192.168.64.1 - - [05/Feb/2022 03:45:00] "GET / HTTP/1.1" 200 - # 访问常规
1234567891011121314151617181920212223
```

2、Compose 将拉取 Redis 映像，为代码生成映像，并启动您定义的服务。在这种情况下，代码在生成时静态复制到映像中。

3、内网和外网在浏览器中输入 http://ip:5000/ 以查看正在运行的应用程序,访问成功。

```shell
[root@192 ~]# curl http://127.0.0.1:5000/
Hello World! I have been seen 6 times.
12
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/fac73620023c425bbe8be2a052adbbaa.png)

查看运行容器和下载的镜像

```shell
[root@192 ~]# docker ps
CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS          PORTS                                       NAMES
69e3e717caab   redis:alpine      "docker-entrypoint.s…"   12 minutes ago   Up 11 minutes   6379/tcp                                    composetest_redis_1
6ee894e2943d   composetest_web   "flask run"              12 minutes ago   Up 11 minutes   0.0.0.0:5000->5000/tcp, :::5000->5000/tcp   composetest_web_1

[root@192 ~]# docker images
REPOSITORY        TAG          IMAGE ID       CREATED          SIZE
composetest_web   latest       f34d94accbfe   17 minutes ago   189MB
python            3.7-alpine   e72b511ad78e   5 hours ago      46.4MB
redis             alpine       3900abf41552   2 months ago     32.4MB
12345678910
```

composetest_web_1 默认服务名： `文件名_服务名_num`
多个服务器，集群。 _num 代表 副本数量

集群状态。服务都不可能只有一个运行实例。弹性，高可用

kubectl service 负载均衡

> 网络

```shell
[root@192 ~]# docker network ls
NETWORK ID     NAME                  DRIVER    SCOPE
72d780a6ab91   bridge                bridge    local
a21a2d695614   composetest_default   bridge    local # 桥接
7e6c1bad6c42   host                  host      local
285b996502c9   none                  null      local
123456
[root@192 ~]# docker network inspect composetest_default 
[root@192 ~]# docker network inspect composetest_default 
[
    {
        "Name": "composetest_default",
        # ...
        "Containers": {
            "69e3e717caab28b75bbc1e7a2ade520efd94508f7835cb6641bb61c530f259a8": {
                "Name": "composetest_redis_1",
                "EndpointID": "982cad680954face54af1e60034399a3d32888ecdfdbf0fbc0de9481966c942a",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "6ee894e2943d88c35d075f036ebbdab0a46cd5252b48296413c8e95d364b514b": {
                "Name": "composetest_web_1",
                "EndpointID": "1a1e07335b2c8ae04b40f9d2283cf0a0c7d46921fb11aebfbca46a7e2259bc28",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": { # compose
            "com.docker.compose.network": "default",
            "com.docker.compose.project": "composetest",
            "com.docker.compose.version": "1.25.5"
        }
    }
]
123456789101112131415161718192021222324252627282930
```

> 关闭服务

```
docker-compose down
1
```

## 1.4 Yaml配置文件规则

对着文档学习：[撰写文件版本 3 参考|Docker 文档](https://docs.docker.com/compose/compose-file/compose-file-v3/)

 yaml配置文件共三层：

```yaml
version: "3" #第一层 版本

services: #第二层 服务
  web:
    build: .
    ports:
      - "5000:5000"
  redis:
    image: "redis:alpine"

#第三层 其他配置  网络/卷、全局规则
volumes: 
networks: :
config:
1234567891011121314
```

> 学习方法

对着文档学习，不会的找就行，官方文档要详细的解释 [撰写文件版本 3 参考|Docker 文档](https://docs.docker.com/compose/compose-file/compose-file-v3/)

![在这里插入图片描述](https://img-blog.csdnimg.cn/5f937fc7151c41d1a2d51bf4562d404f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

> depends_on

depends_on:表达服务之间的依赖关系。depends(取决于)

- 示例：

```yaml
version: "3.9"
services:
  web:
    build: .
    depends_on: # 表示启动web服务前要先启动db和redis服务
      - db
      - redis
  redis:
    image: redis
  db:
    image: postgres
1234567891011
```

服务依赖关系会导致以下行为：

- `docker-compose up`按依赖关系顺序启动服务。在示例中，和 db在redis之web前启动。
- `docker-compose up SERVICE`自动包含 的依赖项。在示例中，SERVIC Edocker-compose up还创建web 并启动 db 和 redis。
- `docker-compose stop`按依赖关系顺序停止服务。在示例中，web 在 db 和 redis 之前停止。

> deploy

 deploy(部署):指定与服务的部署和运行相关的配置。这仅在部署到部署了 docker 堆栈的群 时生效，并且被`docker-compose up`和 `docker-compose run`忽略。

# 2、使用Compose一键部署博客

使用Compose一键部署WordPress博客(推荐一个开源博客系统，FutureCMS)

[Quickstart: Compose and WordPress | Docker Documentation](https://docs.docker.com/samples/wordpress/)

 使用 Docker Compose 在使用 Docker 容器构建的独立环境中轻松运行 WordPress。本快速入门指南演示了如何使用撰写来设置和运行WordPress。

## 2.1 定义项目

1、创建项目目录`/home/my_wordpress`。

例如，如果您将目录命名为 ：`my_wordpress`

```shell
cd my_wordpress/
1
```

2、创建一个启动博客的文件和一个单独的实例，其中包含用于数据持久性的卷装载：

```
docker-compose.yml
version: "3"
    
services:
  db:
    image: mysql:5.7
    volumes:				 # 挂载
      - db_data:/var/lib/mysql 
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: somewordpress # root用户 的 密码
      MYSQL_DATABASE: wordpress # 数据库名
      MYSQL_USER: wordpress # 数据库用户
      MYSQL_PASSWORD: wordpress # 数据库密码
    
  wordpress:
    depends_on: # 依赖项
      - db
    image: wordpress:latest
    volumes:
      - wordpress_data:/var/www/html
    ports:
      - "8000:80"
    restart: always
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
volumes:
  db_data: {}
  wordpress_data: {}
12345678910111213141516171819202122232425262728293031
```

## 2.2 生成项目

现在，从项目目录运行。`docker-compose up -d`

这将在分离模式下运行 [`docker-compose`](https://docs.docker.com/compose/reference/up/)，拉取所需的 Docker 映像，并启动 wordpress 和数据库容器，如下面的示例所示。

```shell
$ docker-compose up -d
1
[root@192 my_wordpress]# docker-compose up -d
Creating network "my_wordpress_default" with the default driver
Creating volume "my_wordpress_db_data" with default driver
Creating volume "my_wordpress_wordpress_data" with default driver
Pulling db (mysql:5.7)...
5.7: Pulling from library/mysql
# ...
Digest: sha256:3e28e1e0b732e1828028d7d500eb73f273fc8365215f633414e60cdc631e0d91
Status: Downloaded newer image for wordpress:latest
Creating my_wordpress_db_1 ... done
Creating my_wordpress_wordpress_1 ... done
1234567891011
```

## 2.3 启动WordPress

此时，WordPress应该在Docker主机的端口8000上运行，您可以作为WordPress管理员完成"著名的五分钟安装"。

> **注意**：WordPress站点不会立即在端口8000上可用，因为容器仍在初始化中，并且可能需要几分钟才能首次加载。

如果您使用的是 Docker Desktop for Mac 或 Docker Desktop for Windows，则可以将其用作 IP 地址，并在 Web 浏览器中打开。 http://localhost:8000或 http://ip:8000

![在这里插入图片描述](https://img-blog.csdnimg.cn/7d21bd33e4cb4c53895581556d9d2659.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/27d5e39d9c544cfa872edb0f2115299f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/8db348949cc74e4894eb232830a325c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/1fc5f6e6447a465181f41cba7a3a550b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

## 2.4 关机和清理

> 查看容器

```shell
[root@192 ~]# docker ps
CONTAINER ID   IMAGE              COMMAND                  CREATED          STATUS          PORTS                                   NAMES
434c7968618f   wordpress:latest   "docker-entrypoint.s…"   16 minutes ago   Up 16 minutes   0.0.0.0:8000->80/tcp, :::8000->80/tcp   my_wordpress_wordpress_1
93d0e3cbbe5b   mysql:5.7          "docker-entrypoint.s…"   16 minutes ago   Up 16 minutes   3306/tcp, 33060/tcp                     my_wordpress_db_1
1234
```

命令 docker-compose 将删除容器和默认网络，但保留您的 WordPress 数据库。

该命令删除容器、默认网络和 WordPress 数据库。

```shell
$ docker-compose down --volumes
1
```

# 3、实战：自己编写微服务上线

## 3.1 创建项目

1、控制器

```java
package com.example.compose.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @Autowired
    StringRedisTemplate redisTemplate;

    @GetMapping("/hello")
    public String hello(){
        // 自增
        Long  view = redisTemplate.opsForValue().increment("views");
        return "hello,this views is: "+view;
    }
}
1234567891011121314151617181920
```

2、application.properties配置文件

```properties
# 应用名称
spring.application.name=Compose
# 应用服务 WEB 访问端口
server.port=8080


spring.redis.host=redis
1234567
```

3、编写Dockerfile，用于构建镜像

```shell
FROM java:8

COPY *.jar /app.jar
CMD ["--server.port=8080"]
EXPOSE 8080
ENTRYPOINT ["java","-jar","app.jar"]
```

4、docker-compose.yml 编排项目
![在这里插入图片描述](https://img-blog.csdnimg.cn/35ccba9db8e14cb8b37e7e3388fdf3c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_8,color_FFFFFF,t_70,g_se,x_16)

```yaml
version: "3"
services:
  myapp:
    build: .
    image: myapp
    depends_on:
      - redis
    ports:
      - "8080:8080"
  redis:
    image: "redis:alpine"
1234567891011
```

5、 macen打包

![在这里插入图片描述](https://img-blog.csdnimg.cn/089f1f67c6a24bb1ae58dd4520225dd3.png)

## 3.2 FTP安装与配置

> **关闭防火墙**

```shell
#关闭防火墙
$ systemctl stop firewalld.service   

#禁止防火墙开机启动
$ systemctl  disable firewalld.service     
12345
```

> 安装

```shell
#安装
yum install -y vsftpd

#设置开机启动
systemctl enable vsftpd.service

#启动
systemctl start vsftpd.service

#停止
systemctl stop vsftpd.service

#查看状态
systemctl status vsftpd.service
1234567891011121314
```

## 3.3 上传文件并运行

> 上传文件

![在这里插入图片描述](https://img-blog.csdnimg.cn/7135eb7b9cf746138a2a98501c274cec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

> 运行

失败原因是关闭防火墙之后docker需要重启，执行以下命令重启docker即可：

```shell
[root@192 myapp]# service docker restart
Redirecting to /bin/systemctl restart docker.service
12
docker-compose up
1
```

- 运行成功

![在这里插入图片描述](https://img-blog.csdnimg.cn/8d89113022074a8f85a1608bbfb94e31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

> 访问测试成功

```shell
[root@192 ~]# curl http://127.0.0.1:8080/hello
hello,this views is: 6
12
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/83a705fc7a6c4a41a1ade1bf9b4d70c3.png)

## 3.4 重新构建

假如项目出错，需要重新构建

```shell
docker-compose ip --build
1
```

# 4、Swarm集群搭建

[Swarm mode overview | Docker Documentation](https://docs.docker.com/engine/swarm/)

## 4.1 环境准备

MobaXterm免费版都比Xshell好用的多，

学生还是用虚拟机吧，内存不够，两台机子用虚拟机桥接网络就可以连通（推荐工具[RdViewer 远程控制软件）

> 服务器(虚拟机)ip

192.168.64.134、192.168.64.135、192.168.64.136、192.168.64.137 （4台服务器: 二主（管理）二从（工作））

![在这里插入图片描述](https://img-blog.csdnimg.cn/09784d42ce9a4f74b52a8103ba7fb6ec.png)

1、4台服务器安装docker

 同时操作服务器，用虚拟机时用同一镜像时不推荐

![在这里插入图片描述](https://img-blog.csdnimg.cn/41c7e3802b694f288da52e3c98e6f8f8.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/0e6c487a84ef4ba382d870ac78d68881.png)

2、 启动Docker并设置开机自启动

```shell
# 启动Docker
$ systemctl start docker

# 查看当前版本号，是否启动成功
$ docker version

# 设置开机自启动
$ systemctl enable docker
12345678
```

## 4.3 Swarm集群介绍

[Docker Swarm 常用命令 - kevin.Xiang - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiangsikai/p/9935814.html)

> 节点工作模式
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/78fe5b3d574a4b8daa80a8b3363f3e39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

> 搭建集群

```shell
$ docker swarm --help

Usage:  docker swarm COMMAND

Manage Swarm 

Commands:
  ca          # Display and rotate the root CA
  init        # 初始化一个Swarm
  join        # 加入一个集群作为一个节点 和/或 管理者
  join-token  # 管理生成的令牌
  leave       # 离开swarm
  unlock      # 解锁swarm
  unlock-key  # 解锁密钥管理
  update      # 更新swarm
123456789101112131415
$ docker swarm init --help
1
```

1、设置主节点（192.168.64.134）

```shell
$ docker swarm init --advertise-addr 192.168.64.134
1
[root@192 ~]# docker swarm init --advertise-addr 192.168.64.134
# Swarm初始化: 当前节点(...)现在是一个manager(管理节点)。
Swarm initialized: current node (n2ws0fm7fvsiniuo9wjmq3dfh) is now a manager.

# 翻译：要添加一个worker(工作节点)到这个swarm，运行以下命令（令牌）
To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-04efiil88xkppw186vk82y5f1 192.168.64.134:2377

# 翻译：要添加一个swarm(管理节点)到swarm，运行'docker swarm join-token manager'，
To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
1234567891011
```

2、生成令牌（管理生成的令牌）

```shell
# 生成管理节点的令牌
$ docker swarm join-token manager

# 生成工作节点的令牌
$ docker swarm join-token worker
12345
[root@192 ~]# docker swarm join-token manager
To add a manager to this swarm, run the following command:
# 【添加一个管理节点的命令】
    docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-4bocoqdhfypuppql3yqxt0u2p 192.168.64.134:2377

[root@192 ~]# docker swarm join-token worker
To add a worker to this swarm, run the following command:
# 【添加一个工作节点的命令】
    docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-04efiil88xkppw186vk82y5f1 192.168.64.134:2377
123456789
```

3、将服务器（192.168.64.135）加入工作节点(在192.168.64.135运行命令)

```shell
# 【添加一个工作节点的命令】
$ docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-04efiil88xkppw186vk82y5f1 192.168.64.134:2377
12
[root@192 ~]# docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-04efiil88xkppw186vk82y5f1 192.168.64.134:2377
This node joined a swarm as a worker.# 成功变为工作节点
12
```

4、查看所有节点信息

```shell
[root@192 ~]# docker node ls
ID                            HOSTNAME         STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
n2ws0fm7fvsiniuo9wjmq3dfh *   192.168.64.134   Ready     Active         Leader           20.10.12
y1clyylemoiqbrquha4hpgdg7     192.168.64.135   Ready     Active                          20.10.12
1234
```

5、将服务器（192.168.64.136）加入工作节点

```shell
# 【添加一个工作节点的命令】
$ docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-04efiil88xkppw186vk82y5f1 192.168.64.134:2377
12
[root@192 ~]# docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-04efiil88xkppw186vk82y5f1 192.168.64.134:2377
This node joined a swarm as a worker.
12
# 查看所有节点信息
[root@192 ~]# docker node ls 
ID                            HOSTNAME         STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
n2ws0fm7fvsiniuo9wjmq3dfh *   192.168.64.134   Ready     Active         Leader           20.10.12
y1clyylemoiqbrquha4hpgdg7     192.168.64.135   Ready     Active                          20.10.12
29g0dvdvrtajsxr5d6lgutddr     192.168.64.136   Ready     Active                          20.10.12
123456
```

6、移除节点

```shell
# 从swarm中删除一个节点 | -f 删除多个节点
$ docker node rm 节点id
12
# 管理节点自己离开
$ docker swarm leave --force

[root@192 ~]# docker swarm leave --force
Node left the swarm.
12345
```

7、将服务器（192.168.64.137）加入管理节点

> 这里manager加不进去的话应该也是要防火墙开放2377端口或**关闭防火墙**

```shell
# 永久关闭防火墙
$ systemctl disable firewalld
$ systemctl stop firewalld

# 停止并禁用开机启动
$ systemctl disable firewalld
123456
# 【添加一个管理节点的命令】
$ docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-4bocoqdhfypuppql3yqxt0u2p 192.168.64.134:2377
12
[root@192 ~]# docker swarm join --token SWMTKN-1-56fs1oaww5jkhsq7f3v2f3fazgm1jgxrvjc1n4cttab8v6bmr8-4bocoqdhfypuppql3yqxt0u2p 192.168.64.134:2377
This node joined a swarm as a manager. # 成功进入管理节点
12
```

8、查看所有节点信息

```shell
[root@192 ~]# docker node ls
ID                            HOSTNAME         STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
n2ws0fm7fvsiniuo9wjmq3dfh *   192.168.64.134   Ready     Active         Leader           20.10.12
y1clyylemoiqbrquha4hpgdg7     192.168.64.135   Ready     Active                          20.10.12
29g0dvdvrtajsxr5d6lgutddr     192.168.64.136   Ready     Active                          20.10.12
mbtufs92q1q1kbsrdkfh3gx7s     192.168.64.137   Ready     Active         Reachable        20.10.12
123456
```

## 4.3 Raft一致性协议了解

双主双从->假设一个节点挂了，其他节点是否可用？ 不可用

Raft协议：保证大多数节点存活才可用

- 三个管理器的群体最多可以容忍一个管理器的损失。
- 一个五管理器群可以容忍最大同时丢失两个管理器节点。
- 一个N管理器集群最多可以容忍管理器的丢失 (N-1)/2。
- Docker 建议一个群最多有七个管理器节点。

ps:manager 节点不是越多越好

- 三个manager节点，停止一个manager之后仍可用
- 三个manager节点，停止两个manager之后不可用

> 实验：

1、一个主节点挂了，另一个主节点也不能用了

```shell
[root@tencent-h1 ~]# systemctl docker 
[root@tencent-h1 ~]# docker node ls
# 日志含义可能在线的managers太少了。确保半数以上的managers在线。
Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online.
1234
```

2、将某一个worker节点离开，仍可用

![image-20220101174838615](https://img-blog.csdnimg.cn/img_convert/c4104236f8db592d11849cfb91f63e94.png)

3、work节点不能查看节点信息，仅用来工作，**命令只能在manager（管理节点）上执行**

```shell
[root@192 ~]# docker node ls
# 来自daemon的错误响应:这个节点不是一个集群管理器。工作节点不能用于查看或修改集群状态。请在管理节点上执行此命令或将当前节点提升为管理节点。
Error response from daemon: This node is not a swarm manager. Worker nodes can't be used to view or modify cluster state. Please run this command on a manager node or promote the current node to a manager.
123
```

# 5、Swarm集群弹性创建服务

扩缩容功能，创建服务，动态扩展服务，更新服务，日志，灰度发布（更新网站（服务）时依旧提出服务，不挂404）

功能：扩缩容功能（扩容：增加容器，缩容:减少容器），灰度发布

目的：创建 nginx 服务、动态扩展服务、动态更新服务

```shell
[root@192 ~]# docker service --help

Usage:  docker service COMMAND

Manage services

Commands:
  create      # 创建一个新服务
  inspect     # 显示一个或多个服务的详细信息
  logs        # 获取服务或任务的日志
  ls          # 服务列表
  ps          # 列出一个或多个服务的任务
  rm          # 删除一个或多个服务
  rollback    # 回滚恢复对服务配置的更改
  scale       # 扩展扩展一个或多个复制业务
  update      # 更新服务

1234567891011121314151617
```

1、创建服务（192.168.64.134）

 以前是docker run(单机)，现在是 docker service (集群)

```shell
$ docker service create -p 8888:80 --name my-nginx nginx
1
```

2、查看服务（192.168.64.134）

```shell
$ docker service ls
1
[root@192 ~]# docker service ls
ID             NAME       MODE         REPLICAS   IMAGE          PORTS
cccvbtrm38lt   my-nginx   replicated   1/1        nginx:latest   *:8888->80/tcp
123
```

虽然是在192.168.64.134机器上创建的，但也有可能跑在其他机器上

```shell
$ docker ps
1
[root@192 ~]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS     NAMES
a9c147315120   nginx:latest   "/docker-entrypoint.…"   About a minute ago   Up About a minute   80/tcp    my-nginx.1.z9q9ym9npjh6nx5mrmz0whcfa
123
```

查看my-nginx 服务的状态

```shell
[root@192 ~]# docker service ps my-nginx
ID             NAME         IMAGE          NODE             DESIRED STATE   CURRENT STATE            ERROR     PORTS
z9q9ym9npjh6   my-nginx.1   nginx:latest   192.168.64.134   Running         Running 28 minutes ago  
123
```

3、动态扩缩容,扩容到3个副本 集群中的任意节点都可访问，实现高可用

```shell
$ docker service update --replicas 3 my-nginx

[root@192 ~]# docker service update --replicas 3 my-nginx
my-nginx
overall progress: 3 out of 3 tasks 
1/3: running   
2/3: running   
3/3: running   
verify: Service converged 
123456789
# 动态扩容成功
[root@192 ~]# docker service ls
ID             NAME       MODE         REPLICAS   IMAGE          PORTS
cccvbtrm38lt   my-nginx   replicated   3/3        nginx:latest   *:8888->80/tcp
1234
```

4、动态扩缩容（scale 同 updata）

```shell
$ docker service scale my-nginx=10
1
[root@192 ~]# docker service ls
ID             NAME       MODE         REPLICAS   IMAGE          PORTS
cccvbtrm38lt   my-nginx   replicated   10/10       nginx:latest   *:8888->80/tcp
123
```

动态更新nginx成3个副本，三台主机上都有nginx服务。（但用第四台主机的ip也能访问到nginx）

![在这里插入图片描述](https://img-blog.csdnimg.cn/25299a55bc054eeeb08b50e8eb79f913.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Liq5bmz5YehZGXkuro=,size_20,color_FFFFFF,t_70,g_se,x_16)

5、动态缩容，回滚到1个

```shell
$ docker service scale my-nginx=1
1
[root@192 ~]# docker service scale my-nginx=1
my-nginx scaled to 1
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================>] 
verify: Service converged 
[root@192 ~]# docker service ls
ID             NAME       MODE         REPLICAS   IMAGE          PORTS
cccvbtrm38lt   my-nginx   replicated   1/1        nginx:latest   *:8888->80/tcp
12345678
```

k8s更难，功能更多。swarm相当于简单版的k8s

> Swarm概念总结

- swarm
  集群的管理和编号。docker可以初始化一个swarm集群，其他节点可以加入。（管理、工作者）
- Node
  就是一个docker节点。多个节点就组成了一个网络集群。（管理、工作者）
- Service
  任务，可以在管理节点或者工作节点来运行。核心。！用户访问！
- Task
  容器内的命令，细节任务！

![image-20220101202222870](https://img-blog.csdnimg.cn/img_convert/418315bef0622cfe4d3b560a9ff2f516.png)