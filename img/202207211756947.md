# 算法模板

---

## 基础算法

---

### 快速排序

```java
// 基于分治
static void quick_start(int q[], int l, int r) {
  if (l>=r) return;
  // 确定分界点
  int x = q[l];
  // 左右边界
  int i = l - 1;
  int j = r + 1;
  while (i < j) {
      do {
          i++;
      } while (q[i] < x);
      do {
          j--;
      } while (q[j] > x);
      // 调整区间：第一个区间所有的数小于x，第二个区间都大于x
      if (i<j) {
          int temp = q[i];
          q[i] = q[j];
          q[j] = temp;
      }
  }
  quick_start(q,l,j);
  quick_start(q,j+1,r);
}
```

### 归并排序

```java
// 基于分治
public static void merge_sort(int[] q, int l, int r) {
    if (l >= r) return;
    // 确定分界
    int mid = l + r >> 1;
    // 递归排序
    merge_sort(q,l,mid);
    merge_sort(q,mid+1,r);
    
    int k = 0;
    int i = l;
    int j = mid + 1;
    // 合二为一
    while (i<=mid && j<=r) {
        if (q[i]<=q[j]) {
            temp[k++] = q[i++];
        } else {
            temp[k++] = q[j++];
        }
    }
    while (i<=mid) {
        temp[k++] = q[i++];
    }
    while (j<=r) {
        temp[k++] = q[j++];
    }
    for (i=l,j=0; i<=r; i++,j++) {
         q[i] = temp[j];
    }
}
```

### 二分

```java
// 二分的本质并不是单调性
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

public static void main(String[] args) throws IOException {

    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

    String[] val = bf.readLine().split(" ");
    int n = Integer.parseInt(val[0]);
    int q = Integer.parseInt(val[1]);

    int[] a = new int[n];

    String[] cur = bf.readLine().split(" ");

    for (int i=0; i<n; i++) {
        a[i] = Integer.parseInt(cur[i]);
    }
    while (q-- != 0) {

        String[] b = bf.readLine().split(" ");
        int x = Integer.parseInt(b[0]);

        int l = 0;
        int r = n - 1;

        while (l < r) {

            int mid = l + r >> 1;
            // 从左往右看第一个满足大于等于x的数字
            if (a[mid] >= x) {
                r = mid;
            } else {
                l = mid + 1;
            }

        }
        if (a[l] != x) {
            System.out.println("-1 -1");
        } else {
            System.out.print(l + " ");
            l = 0;
            r = n - 1;

            while (l < r) {
                int mid = l + r + 1 >> 1;
                // 此处 l = mid 如果上面mid = l+r >> 1的话，那么下面的l = mid就有可能成为l = l发生死循环
                if (a[mid] <= x) {
                    l = mid;
                } else {
                    r = mid - 1;
                }
            }
            System.out.print(l);
            System.out.println();
        }
    }
}
```

### 前缀和

```java
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

### 子矩阵和

````java
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
    /**
 * 796. 子矩阵的和
 */
public class AC796 {

    private static int N = 1010;

    public static void main(String[] args) throws IOException {

        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

        String[] val = bf.readLine().split(" ");
        int n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);
        int q = Integer.parseInt(val[2]);

        int[][] a = new int[N][N];
        int[][] s = new int[N][N];

        for (int i=1; i<=n; i++) {
            String[] cur = bf.readLine().split(" ");
            for (int j=1; j<=m; j++) {
                a[i][j] = Integer.parseInt(cur[j-1]);
                s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; // 求前缀和
            }
        }

        while (q-- != 0) {

            String[] cur1 = bf.readLine().split(" ");
            int x1 = Integer.parseInt(cur1[0]);
            int y1 = Integer.parseInt(cur1[1]);
            int x2 = Integer.parseInt(cur1[2]);
            int y2 = Integer.parseInt(cur1[3]);

            System.out.println(s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]); // 算字矩阵的和
        }
    }
}
````

### 一维差分

```java
/**
 * 在a[L,R]上加c
 * 就相当于在b[L]+=c   b[R+1]-=c  因为在L~R之间都加c，那么R之后的一个就要减去这个c
 */
//给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
public class 差分 {
    private static final int N = 100010;
    private static int[] a = new int[N];
    private static int[] b = new int[N];
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String[] val = bf.readLine().split(" ");
        int n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);
        String[] cur = bf.readLine().split(" ");
        for (int i=1; i<=n; i++) {
            a[i] = Integer.parseInt(cur[i-1]);
            insert(i,i,a[i]);
        }
        while (m-- != 0) {
            String[] cur1 = bf.readLine().split(" ");
            int l = Integer.parseInt(cur1[0]);
            int r = Integer.parseInt(cur1[1]);
            int c = Integer.parseInt(cur1[2]);
            insert(l,r,c);
        }
        for (int i=1; i<=n; i++) {
            b[i] += b[i-1];
        }
        for (int i=1; i<=n; i++) {
            System.out.print(b[i] + " ");
        }
    }
    private static void insert(int i, int j, int a) {
        b[i] += a;
        b[j+1] -= a;
    }
}
```

### 二维差分

```java
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
public class AC798 {
    private static final int N = 1010;
    private static int[][] a = new int[N][N];
    private static int[][] b = new int[N][N];
    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String[] val = bf.readLine().split(" ");
        int n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);
        int q = Integer.parseInt(val[2]);
        for (int i=1; i<=n; i++) {
            String[] cur = bf.readLine().split(" ");
            for (int j=1; j<=m; j++) {
                a[i][j] = Integer.parseInt(cur[j-1]);
                insert(i,j,i,j,a[i][j]);
            }
        }
        while (q-- != 0) {
            String[] cur1 = bf.readLine().split(" ");
            int x1 = Integer.parseInt(cur1[0]);
            int y1 = Integer.parseInt(cur1[1]);
            int x2 = Integer.parseInt(cur1[2]);
            int y2 = Integer.parseInt(cur1[3]);
            int c = Integer.parseInt(cur1[4]);
            insert(x1,y1,x2,y2,c);
        }
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=m; j++) {
                b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];
            }
        }
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=m; j++) {
                System.out.print(b[i][j] + " ");
            }
            System.out.println();
        }
    }
    private static void insert(int x1, int y1, int x2, int y2, int c) {
        b[x1][y1] += c;
        b[x2+1][y1] -= c;
        b[x1][y2+1] -= c;
        b[x2+1][y2+1] += c;
    }
}

```

### 位运算 

````java
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n //1010返回10   101000返回1000
````



## 数据结构

---

### 单链表(领接表，存储图和树)

````java
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
public class AC826 {
    
    private static final int N = 100010;
    // 某个点的值是多少
    private static int[] e = new int[N];
    // 每个点的next值
    private static int[] ne = new int[N];
    private static int head = -1;
    // 存储当前已经用到了哪个点
    private static int idx = 0;

    // 将x插到头节点
    private static void add_to_head(int x) {
        // 存值
        e[idx] = x;
        ne[idx] = head;
        head = idx++;
    }

    // 将x插到下标为k的点后面
    private static void insert(int k, int x) {
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx++;
    }
    // 将k点后面的点删掉
    private static void remove(int k) {
//        ne[k] = ne[++k];
        ne[k] = ne[ne[k]];
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        int M = sc.nextInt();

        while (M-- > 0) {
            String str = sc.next();
            if (str.equals("H")) {
                int x = sc.nextInt();
                add_to_head(x);
            } else if (str.equals("I")) {
                int k = sc.nextInt();
                int x = sc.nextInt();
                insert(k - 1, x);
            } else if (str.equals("D")) {
                int k = sc.nextInt();
                if (k == 0)
                    head = ne[head];
                else {
                    remove(k - 1);
                }
            }
        }
        int i = head;
        while (i != -1) {
            System.out.print(e[i] + " ");
            i = ne[i];
        }
    }
}
````

### 双链表

````java
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}

public class AC827 {
    private static final int N = 100010;
    // 值
    private static int[] e = new int[N];
    // 左
    private static int[] l = new int[N];
    // 右
    private static int[] r = new int[N];
    private static int idx;

    static void init(){
        r[0]=1;
        l[1]=0;
        idx=2;
    }

    private static void add(int k, int x) {
        e[idx] = x;
        r[idx] = r[k];
        l[idx] = k;
        // 先改r[k] 的左指针然后再改右指针
        l[r[k]] = idx;
        r[k] = idx;
        idx++;
    }

    // 删除第k个点
    private static void remove(int k) {
        r[l[k]] = r[k];
        l[r[k]] = l[k];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));

        int M = Integer.parseInt(bf.readLine());

        init();

        while(M-->0){
            String[]arr=bf.readLine().split(" ");
            String op=arr[0];

            if(op.equals("L")){
                int x = Integer.parseInt(arr[1]);
                add(0, x);
            }else if(op.equals("R")){
                int x = Integer.parseInt(arr[1]);
                add(l[1], x);
            }else if(op.equals("D")){
                int k = Integer.parseInt(arr[1]);
                remove(k+1);
            }else if(op.equals("IL")){
                int k = Integer.parseInt(arr[1]);
                int x = Integer.parseInt(arr[2]);
                add(l[k+1], x);
            }else{
                int k = Integer.parseInt(arr[1]);
                int x = Integer.parseInt(arr[2]);
                add(k+1, x);
            }
        }

        for(int i=r[0]; i!=1; i=r[i]) {
            System.out.print(e[i]+" ");
        }
    }

}

````

### 模拟栈

````java
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0)
{

}
public class 模拟栈 {

    private static final int N = 100010;
    private static int[] stk = new int[N];
    // 栈底下标
    private static int tt = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int M = Integer.parseInt(br.readLine());
        while (M-- != 0) {
            String[] cur = br.readLine().split(" ");
            if (cur[0].equals("push")) {
                stk[++tt] = Integer.parseInt(cur[1]);
            } else if (cur[0].equals("pop")) {
                tt--;
            } else if (cur[0].equals("empty")) {
                System.out.println(tt==0?"YES":"NO");
            } else {
                System.out.println(stk[tt]);
            }
        }
    }
}
````

### 模拟队列

````java
1. 普通队列：
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh <= tt)
{

}
2. 循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}

public class AC829 {
    private static final int N = 100010;
    private static int[] q = new int[N];
    private static int hh = 0;
    private static int tt = -1;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int M = Integer.parseInt(br.readLine());
        while (M-- != 0) {
            String[] cur = br.readLine().split(" ");
            if (cur[0].equals("push")) {
                q[++tt] = Integer.parseInt(cur[1]);
            } else if (cur[0].equals("pop")) {
                hh++;
            } else if (cur[0].equals("empty")) {
                System.out.println(hh<=tt?"NO":"YES");
            } else {
                System.out.println(q[hh]);
            }
        }
    }
}
````

### 单调栈

```java
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}

/**
 * 830. 单调栈
 */
public class AC830 {

    private static final int N = 100010;
    private static int[] stk = new int[N];
    private static int tt = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[] cur = br.readLine().split(" ");
        for (int i=0; i<n; i++) {
            int x = Integer.parseInt(cur[i]);
            while (tt!=0 && stk[tt] >= x) {
                tt--;
            }
            if (tt!=0) {
                System.out.print(stk[tt] + " ");
            } else {
                System.out.print("-1 ");
            }
            stk[++tt] = x;
        }
    }
}
```

### KMP

```java
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}

/**
 * 831. KMP字符串
 * s母 p子
 */
public class AC831 {

    static int N = 100010;
    static int ne[] = new int[N];

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        Integer n = Integer.parseInt(br.readLine());
        String s1 = " " + br.readLine();
        Integer m = Integer.parseInt(br.readLine());
        String s2 = " " + br.readLine();
        char[] p = s1.toCharArray();
        char[] s = s2.toCharArray();

        //ne  n
        for (int i=2,j=0; i<=n; i++) {
            while (j!=0 && p[i]!=p[j+1]) {
                j = ne[j];
            }
            if (p[i] == p[j+1]) {
                j++;
            }
            ne[i] = j;
        }

        // 匹配 m
        for (int i=1,j=0; i<=m; i++) {
            while (j!=0 && s[i]!=p[j+1]) {
                j = ne[j];
            }
            if (s[i] == p[j+1]) {
                j++;
            }
            if (j == n) {
                j = ne[j];
                bw.write(i-n + " ");
            }
        }
        bw.flush();
    }
    
}
```

### 并查集

```java
将两个集合合并/询问两个元素是否在一个集合当中
(1)朴素并查集：
    int p[N]; //存储每个点的祖宗节点
    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
(2)维护size的并查集：
    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量
    // 返回x的祖宗节点
    int find(int x)
    {
        return p[x];
    }
    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
(3)维护到祖宗节点距离的并查集：
    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离
    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量

/**
 * 836. 合并集合
 */
public class AC836 {

    private static final int N = 100010;
    private static int[] p = new int[N];

    private static int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String[] val = br.readLine().split(" ");

        int n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);

        for (int i=1; i<=n; i++) {
            p[i] = i;
        }

        while (m-- != 0) {

            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[1]);
            int b = Integer.parseInt(cur[2]);
            if (cur[0].equals("M")) {
                p[find(a)] = find(b);
            } else {
                if (find(a) == find(b)) {
                    System.out.println("Yes");
                } else {
                    System.out.println("No");
                }
            }
        }
    }
}

/**
 *AcWing 837. 连通块中点的数量
 */
public class AC837 {

    private static final int N = 100010;
    private static int[] p = new int[N];
    private static int[] size = new int[N];

    // 返回x所在集合的编号  返回x的祖宗节点 + 路径压缩
    private static int find(int x) {
        if (p[x] != x) {
            p[x] = find(p[x]);
        }
        return p[x];
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int m = sc.nextInt();

        for (int i=1; i<=n; i++) {
            p[i] = i;
            size[i] = 1;
        }

        while (m-- != 0) {

            String op = sc.next();

            if (op.equals("C")) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                // 如果已经在一个集合中，则不需要任何判断了
                if (find(a) == find(b)) {
                    continue;
                }
                size[find(b)] += size[find(a)];
                // a的祖宗节点的父亲等于b的祖宗节点
                p[find(a)] = find(b);
            } else if (op.equals("Q")){
                int a = sc.nextInt();
                int b = sc.nextInt();
                if (find(a) == find(b)) {
                    System.out.println("Yes");
                } else {
                    System.out.println("No");
                }
            } else {
                int a = sc.nextInt();
                System.out.println(size[find(a)]);
            }
        }

    }

}

```

### 堆排序

```Java
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);


/**
 * 838. 堆排序
 */
public class AC838 {
    private static final int N = 100010;
    private static int[] h = new int[N];
    private static int size = 0;
    private static void down(int u) {
        int t = u;
        if (2*u<size && h[2*u]<h[t]) {
            t = u*2;
        }
        if (2*u+1<size && h[2*u+1]<h[t]) {
            t = u*2+1;
        }
        if (u != t) {
            int temp = h[u];
            h[u] = h[t];
            h[t] = temp;
            down(t);
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] val = br.readLine().split(" ");
        int n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);
        size = n;
        String[] cur = br.readLine().split(" ");
        for (int i=0; i<n; i++) {
             h[i] = Integer.parseInt(cur[i]);
        }
        for (int i=n/2; i>=0; i--) {
            down(i);
        }
        while (m-- != 0) {
//            bw.write(h[1] + " ");
            System.out.print(h[1] + " ");
            h[1] = h[size];
            size--;
            down(1);
        }
    }  
}
```

### 模拟堆

```java
/**
 * 839、模拟堆
 */
public class AC839 {

    private static final int N = 100010;
    private static int[] ph = new int[N];
    private static int[] hp = new int[N];
    private static int[] h = new int[N];
    private static int size = 0;
    private static int m = 0;

    private static void heap_swap(int a, int b) {

        int temp = ph[hp[a]];
        ph[hp[a]] = ph[hp[b]];
        ph[hp[b]] = temp;

        int temp2 = hp[a];
        hp[a] = hp[b];
        hp[b] = temp2;

        int temp3 = h[a];
        h[a] = h[b];
        h[b] = temp3;

    }

    private static void down(int u) {
        int t = u;
        if (2*u<=size && h[2*u] < h[t]) {
            t = 2*u;
        }
        if (2*u+1 <= size && h[2*u+1] < h[t]) {
            t = 2*u+1;
        }
        if (u!=t) {
            heap_swap(t,u);
            down(t);
        }

    }

    private static void up(int u) {
        while (u/2>0 && h[u/2]>h[u]) {
            heap_swap(u,u/2);
            u /= 2;
        }
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        while (n-- != 0) {

            String[] cur = br.readLine().split(" ");

            if (cur[0].equals("I")) {
                int x = Integer.parseInt(cur[1]);
                size++;
                m++;
                ph[m] = size;
                hp[size] = m;
                h[size] = x;
                up(size);
            } else if (cur[0].equals("PM")) {
                System.out.println(h[1]);
            } else if (cur[0].equals("C")) {
                int k = Integer.parseInt(cur[1]);
                int x = Integer.parseInt(cur[2]);
                k = ph[k];
                h[k] = x;
                down(k);
                up(k);
            } else if (cur[0].equals("DM")) {
                heap_swap(size,1);
                size--;
                down(1);
            } else {
                int k = Integer.parseInt(cur[1]);
                k = ph[k];
                heap_swap(size, k);
                size--;
                down(k);
                up(k);
            }
        }
    }
}
```

### Java中的堆

````java
PriorityQueue<Integer> b = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;//大顶堆
                //return o1-o2;//小顶堆
            }
        });
PriorityQueue<Integer> b = new PriorityQueue<>((o1,o2)->o2-o1); // 大顶堆
````

### 散列表

````java
/**
 * 840. 模拟散列表
 * 拉链
 */
public class AC840 {

    private static final int N = 100003; // 质数
    private static final int N2 = 200003;
    private static final int null1 = 0x3f3f3f3f;
    private static int[] h = new int[N];
    private static int[] e = new int[N];
    private static int[] ne = new int[N];
    private static int idx = 0;


    private static void insert(int x) {
        // k 哈希值
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx++;

    }

    // 拉链法
    private static boolean find(int x) {
        int k = (x % N + N) % N;

        for (int i=h[k]; i!=-1; i=ne[i]) {
            if (e[i] == x) {
                return true;
            }
        }
        return false;

    }

    // 开放寻址
    private static int find2(int x) {
        int k = (x%N2 + N2) % N2;
        while (h[k] != null1 && h[k] != x) {
            k++;
            if (k==N2) {
                k = 0;
            }
        }
        return k;
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        // 拉链
        Arrays.fill(h,-1);
        // 开放寻址
//        Arrays.fill(h,0x3f);

        while (n-- != 0) {
            String[] cur = br.readLine().split(" ");
//
//            if (cur[0].equals("I")) {
//                int x = Integer.parseInt(cur[1]);
//                int k = find2(x);
//                h[k] = x;
//            } else if (cur[0].equals("Q")) {
//                int x = Integer.parseInt(cur[1]);
//                int k = find2(x);
//                h[k] = x;
//                if (h[k] != null1) {
//                    System.out.println("Yes");
//                } else {
//                    System.out.println("No");
//                }
//            }

            if (cur[0].equals("I")) {
                int x = Integer.parseInt(cur[1]);
                insert(x);
            } else if (cur[0].equals("Q")) {
                int x = Integer.parseInt(cur[1]);
                if (find(x)) {
                    System.out.println("Yes");
                } else {
                    System.out.println("No");
                }
            }

        }

    }

}

````



### 字符串哈希

````java
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

/**
 *  841. 字符串哈希
 */
public class AC841 {


    static int N = 100010,P = 131;
    static long h[] = new long[N];
    // 存储p的多少次方
    static long p[] = new long[N];

//      1           2          3        4        5
//      a[1]*10000 a[2]*1000 a[3]*100 a[4]*10  a[5]*1
//      a[1]*100   a[2]*10   a[3]*1
//      第二行需要乘上100再被第一行减，才能得到4 5位置的数字
    private static long get(int l, int r) {
        return h[r] - h[l-1]*p[r-l+1];
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String[] val = br.readLine().split(" ");

        int n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);

        String s1 = " " + br.readLine();
        char[] a = s1.toCharArray();

        p[0] = 1;

        for (int i = 1; i <= n; i++) {
            h[i] = h[i - 1] * P + a[i];
            p[i] = p[i - 1] * P;
        }

        while (m-- != 0) {
            String[] cur = br.readLine().split(" ");
            int l1 = Integer.parseInt(cur[0]);
            int r1 = Integer.parseInt(cur[1]);
            int l2 = Integer.parseInt(cur[2]);
            int r2 = Integer.parseInt(cur[3]);
            System.out.println(get(l1, r1) == get(l2, r2) ? "Yes" : "No");
        }

    }

}
````



## 搜索与图论

---

### 图的存储

```java
树与图的存储
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：g[a][b] 存储边a->b

(2) 邻接表：

// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

### DFS

```java
/**
 * AcWing 842. 排列数字
 */
public class AC842 {
    static final int N = 10;
    static int[] path = new int[N];
    static boolean[] st = new boolean[N];
    static int n;
    static void dfs(int u) {
        if (u == n) {
            for (int i=0; i<n; i++) {
                System.out.print(path[i] + " ");
            }
            System.out.println();
            return;
        }
        for (int i=1; i<=n; i++) {
            if (!st[i]) {
                path[u] = i;
                st[i] = true;
                dfs(u+1);
                st[i] = false;
            }
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());
        dfs(0);
    }
}
```

### BFS(最短，边的权重是1)

```java
/**
 * bfs
 * 844. 走迷宫
 */
public class AC844 {

    private static final int N = 110;
    private static int[][] g = new int[N][N];
    private static int[][] d = new int[N][N];
    private static PI[] q = new PI[N*N];
    private static int n;
    private static int m;

    private static int bfs() {
        int hh = 0;
        int tt = 0;
        // 初始化队列
        q[0] = new PI(0,0);

        // 初始化距离
        for (int i=0; i<n; i++) {
            for (int j=0; j<m; j++) {
                d[i][j] = -1;
            }
        }

        d[0][0] = 0;

        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        while (hh <= tt) {
            // 出队
            PI t = q[hh++];
            for (int i=0; i<4; i++) {
                int x = t.getFirst() + dx[i];
                int y = t.getSecond() + dy[i];
                if (x>=0 && x<n && y>=0 && y<m && d[x][y]==-1 && g[x][y]==0) {
                    d[x][y] = d[t.getFirst()][t.getSecond()] + 1;
                    // 添加到队列中
                    q[++tt] = new PI(x,y);
                }
            }

        }
        return d[n-1][m-1];
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String[] val = br.readLine().split(" ");
        n = Integer.parseInt(val[0]);
        m = Integer.parseInt(val[1]);

        for (int i=0; i<n; i++) {
            String[] cur = br.readLine().split(" ");
            for (int j=0; j<m; j++) {
                g[i][j] = Integer.parseInt(cur[j]);
            }
        }

        System.out.println(bfs());

        br.close();

    }

}

class PI {
    private int first;
    private int second;

    public PI(int first, int second) {
        this.first = first;
        this.second = second;
    }

    public PI() {

    }

    public int getFirst() {
        return first;
    }

    public int getSecond() {
        return second;
    }
}


/**
 * 847. 图中点的层次
 */
从1到n
public class AC847 {

        private static final int N = 100010;

        private static int idx, n, m;

        private static int[] h = new int[N], e = new int[N], ne = new int[N], d = new int[N], q = new int[N];

        public static void main(String[] args) throws IOException {

            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

            String[] str1 = reader.readLine().split(" ");
            n = Integer.parseInt(str1[0]);
            m = Integer.parseInt(str1[1]);

            for (int i = 0; i < h.length; i++) {
                h[i] = -1;
            }

            for (int i = 0; i < m; i++) {
                String[] str2 = reader.readLine().split(" ");
                add(Integer.parseInt(str2[0]), Integer.parseInt(str2[1]));
            }

            System.out.println(bfs());
            reader.close();
        }

        private static void add(int a, int b) {
            e[idx] = b;
            ne[idx] = h[a];
            h[a] = idx++;
        }

        private static int bfs() {
            int hh = 0, tt = 0;

            q[0] = 1;

            Arrays.fill(d,-1);

            d[1] = 0;
            while (hh <= tt) {
                int t = q[hh++];
                for (int i = h[t]; i != -1; i = ne[i]) {
                    int j = e[i];
                    if (d[j] == -1) {
                        d[j] = d[t] + 1;
                        q[++tt] = j;
                    }
                }
            }
            return d[n];
        }

}

```

### 拓扑序列

```java
/**
 * 848. 有向图的拓扑序列
 */
// 所有边都是从前指向后的。没有环，一定不能展开成为从前向后
// 有向无环图称为拓扑图
public class AC848 {

    static final int N = 100010;
	
    // 领接表
    static int[] h = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int idx;

    static int[] d = new int[N];//入度
    static int[] q = new int[N];// 队列

    static int n;
    static int m;

    static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    static boolean topsort() {
        int hh = 0;
        int tt = -1;

        for (int i=1; i<=n; i++) {
            if (d[i] == 0) {
                q[++tt] = i;
            }
        }

        while (hh<=tt) {
            // 取队头
            int t = q[hh++];
            for (int i=h[t]; i!=-1; i=ne[i]) {
                int j = e[i];
                // 删除
                d[j]--;
                // j前面的所有点都已经放好了
                if (d[j] == 0) {
                    // j入队
                    q[++tt] = j;
                }
            }
        }
        return tt == n-1;
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String[] val = br.readLine().split(" ");

        n = Integer.parseInt(val[0]);
        m = Integer.parseInt(val[1]);

        Arrays.fill(h,-1);


        while (m-- != 0) {
            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            add(a,b);
            d[b]++;
        }

        if (topsort()) {
            for (int i=0; i<n; i++) {
                System.out.print(q[i] + " ");
            }
        } else {
            System.out.println(-1);
        }

    }
}
```

### 最短路

 ```java
  单源最短路：（只有一个起点）
      从一个点到其他所有点的最短路，从一到n的最短路也就知道了
      1.所有边都是正数 
      		朴素版本的Dijkstra  O(n^2) 适合于稠密图   Dijkstra求最短路
      		堆优化版的Dijkstra   O(m log n)   Dijkstra求最短路 II
      如何区分稠密图？看n、m，相差不多那么就是稀疏图  m和n^2是一个级别那就是稠密图
      2.存在负权边
      		bellman-ford算法 O(nm)
      		spfa 一般O(m) 最坏O(nm)
  多源汇最短路：
      很多个询问，任意一个点到另一个点的最短路
      Floyd O(n^3)
 ```

### Dijkstra求最短路

```java
/**
 * Dijkstra求最短路 I
 */
public class AC849 {
    static int N = 510;
    static int[][] g = new int[N][N];// 存储每条边
    static int[] dist = new int[N]; // 存储1号点到每个点的最短距离
    static boolean[] st = new boolean[N];// 存储每个点的最短路是否已经确定
    static int n;
    static final int max = 5000000;
    static int dijkstra() {
        // 初始化
        Arrays.fill(dist,max);
        dist[1] = 0;
        for (int i=0; i<n; i++) {
            int t =  -1;
            // 寻找最小
            for (int j=1; j<=n; j++) {
                // 当前这个点还没有确定最短路
                if (st[j]) {
                    continue;
                }
                // t不是最短的
                if (t==-1 || dist[t]>dist[j]) {
                    t = j;
                }
            }
            // 把t加入最短
            st[t] = true;
            // 更新
            for (int j=1; j<=n; j++) {
                if (dist[j] > dist[t] + g[t][j]) {
                    dist[j] = dist[t] + g[t][j];
                }
            }
        }
        if (dist[n] == max) {
            return -1;
        } else {
            return dist[n];
        }
    }
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] val = br.readLine().split(" ");
        n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);
        for (int i=0; i<n; i++) {
            Arrays.fill(g[i],max);
        }
        while (m-- != 0) {
            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            int c = Integer.parseInt(cur[2]);
            g[a][b] = Math.min(g[a][b], c);
        }
        System.out.println(dijkstra());
    }
}
```

### Dijkstra求最短路 II

```java
/**
 * 850. Dijkstra求最短路 II
 * https://learnku.com/articles/35637
 */
public class AC850 {
    /**
     * @Test
     * public void testPriorityQueue(){
     *     //默认采用的是最小堆实现的
     *     PriorityQueue<Integer> queue = new PriorityQueue<Integer>(10,new Comparator<Integer>(){
     *         public int compare(Integer a, Integer b){
     *             return a-b; //if a>b 则交换，so这是递增序列
     *         }
     *     });
     *     queue.offer(13);
     *     queue.offer(9);
     *     int len = queue.size();
     *     for(int i=0;i<len;i++){
     *         System.out.println(queue.poll());
     *     }
     *     //输出 9  13
     *     //默认采用的是最小堆实现的
     *     PriorityQueue<Integer> queue2 = new PriorityQueue<>(10);
     *     queue2.offer(11);
     *     queue2.offer(9);
     *     len = queue2.size();
     *     for(int i=0;i<len;i++){
     *         System.out.println(queue2.poll());
     *     }
     *     //输出 9， 11
     *     }
     */

    static int N = 100010;
    static int n, m, idx;
    // 邻接表
    static int [] h = new int [N];
    static int [] w = new int [N];
    static int [] e = new int [N];
    static int [] ne = new int [N];

    static int [] dist = new int [N];
    static boolean [] st = new boolean [N];

    private static void add(int a, int b, int c) {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    public static void main (String [] args) throws Exception{

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));

        String [] values = br.readLine().split(" ");
        n = Integer.parseInt(values[0]);
        m = Integer.parseInt(values[1]);
        // 初始化领接表
        Arrays.fill(h, -1) ;
        while (m-- > 0) {
            values = br.readLine().split(" ");
            int a = Integer.parseInt(values[0]);
            int b = Integer.parseInt(values[1]);
            int c = Integer.parseInt(values[2]);
            add(a, b, c);
        }

        int ret = dijkstra(n);
        log.write(ret + "\n");
        log.flush();
        log.close();
        br.close();
    }
    private static int dijkstra (int n){
        PriorityQueue<int[]> pq = new PriorityQueue<>(n, (a, b) -> {return a[1] - b[1];});
        int INF = 1 << 30 ;
        Arrays.fill(dist,INF);
        pq.offer(new int []{1, 0});
        dist[1] = 0 ;
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int ver = cur[0];
            int distance = cur[1];
            if (st[ver]) continue;
            st[ver] = true;
            for (int i = h[ver]; i != -1; i = ne[i]){
                int j = e[i];
                if (dist[j] > distance + w[i]){
                    dist[j] = distance + w[i];
                    pq.offer(new int [] {j, dist[j]});
                }
            }
        }
        return dist[n] == INF ? -1 : dist[n];
    }
}
```

### bellman-ford

````java
/**
 * 853. 有边数限制的最短路
 */
public class AC853 {
    static int N = 510;
    static int M = 100010;
    static Edge[] edge = new Edge[M];
    static int[] dist = new int[N];
    static int[] back = new int[N];
    static int n,m,k;
    static final int max = 0x3f3f3f;

    // 求1到n的最短路距离，如果无法从1走到n，则返回-1。
    static int bellman_ford() {
        Arrays.fill(dist,0x3f3f3f);
        dist[1] = 0;
        // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
        for (int i=0; i<k; i++) {
            // 只用上一次迭代的结果来copy  才不会发生串联
            back = dist.clone();
            for (int j=0; j<m; j++) {
                Edge e = edge[j];
                dist[e.b] = Math.min(dist[e.b], back[e.a]+e.c);
            }
        }
        return dist[n];
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] val  = br.readLine().split(" ");
        n = Integer.parseInt(val[0]);
        m = Integer.parseInt(val[1]);
        k = Integer.parseInt(val[2]);
        for (int i=0; i<m; i++) {
            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            int c = Integer.parseInt(cur[2]);
            edge[i] = new Edge(a,b,c);
        }
        if (bellman_ford() > (0x3f3f3f>>1)) {
            System.out.println("impossible");
        } else {
            System.out.println(dist[n]);
        }
    }
}
// 边，a表示出点，b表示入点，c表示边的权重
class Edge{
    int a;
    int b;
    int c;

    public Edge() {
    }

    public Edge(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}
````

### spfa 算法（队列优化的Bellman-Ford算法）

````java
/**
 * 851. spfa求最短路
 */
public class AC851 {
    static final int N = 100010;
    // 领接表
    static int[] h = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int[] w = new int[N];
    static int idx;
    static int[] dist = new int[N]; // 存储每个点到1号点的最短距离
    static boolean[] st = new boolean[N]; // 存储每个点是否在队列中
    static final int max = (int)1e9;
    static int n,m;

    static void add(int a, int b, int c) {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx++;
    }
    // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
    static int spfa() {
        Arrays.fill(dist,max);
        dist[1] = 0;
        st[1] = true;
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(1);

        while (!q.isEmpty()) {
            // 出队
            int cur = q.poll();
            st[cur] = false;

            // 从邻接表头开始遍历
            for (int i=h[cur]; i!=-1; i=ne[i]) {
                int j = e[i];
                //如果当前节点可以被更新，就做更新操作，并将该节点加入到队列中
                if (dist[j] > dist[cur] + w[i]) {
                    dist[j] = dist[cur] + w[i];
                    if (!st[j]) {
                        q.add(j);
                        st[j] = true;
                    }
                }
            }
        }
        return dist[n];
    }

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] val = br.readLine().split(" ");
        n = Integer.parseInt(val[0]);
        m = Integer.parseInt(val[1]);

        Arrays.fill(h,-1);

        while (m-- != 0) {
            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            int c = Integer.parseInt(cur[2]);
            add(a,b,c);
        }

        int t = spfa();
        if (t == max) {
            System.out.println("impossible");
        } else {
            System.out.println(t);
        }

    }

}

````

### spfa判断图中是否存在负环

```java
/**
 * 852. spfa判断负环
 */
public class AC852 {

    static int N = 100010;

    static int[] h = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int[] w = new int[N];
    // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
    static int[] dist = new int[N];
    static int[] cnt = new int[N];
    
    static boolean[] st = new boolean[N];
    static int idx;
    static int n;

    static void add(int a, int b, int c){
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    static boolean spfa(){
        //声明一个队列保存更新过的节点
        Queue<Integer> q = new LinkedList<Integer>();
        for (int i=1; i<=n; i++) {
            st[i] = true;
            q.offer(i);
        }
        while(!q.isEmpty()){
            int cur = q.poll();
            st[cur] = false;
            for(int i=h[cur]; i!=-1; i=ne[i]){
                int j = e[i];
                //如果当前节点可以被更新，就做更新操作，并将该节点加入到队列中
                if(dist[j] > dist[cur] + w[i]){
                    dist[j] = dist[cur] + w[i];
                    // 一条边变成两条边
                    cnt[j] = cnt[cur] + 1;
                    // 1~x 至少经过了 n+1个点  表示有负环 抽屉原理
                    if (cnt[j] > n) {
                        return true;
                    }
                    if(!st[j]){
                        q.add(j);
                        st[j] = true;
                    }
                }
            }
        }
        return false;
    }

    public static void main(String[]args) throws IOException{

        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

        String[] cur = in.readLine().split(" ");
        n = Integer.parseInt(cur[0]);
        int m = Integer.parseInt(cur[1]);

        Arrays.fill(h, -1);
        while(m-->0){
            String[] arr = in.readLine().split(" ");
            int a = Integer.parseInt(arr[0]);
            int b = Integer.parseInt(arr[1]);
            int c = Integer.parseInt(arr[2]);

            add(a, b, c);
        }

        if(spfa()) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }
    }
}

```

### floyd算法

````java
/**
 * 854. Floyd求最短路
 */
public class AC854 {

    static int N = 250;
    static int[][] g = new int[N][N];
    static int n,m;
    static int max = 0x3f3f3f3f;

    static void floyd(){
        for(int k=1; k<=n; k++){
            for(int i=1; i<=n; i++){
                for(int j=1; j<=n; j++){
                    g[i][j] = Math.min(g[i][k]+g[k][j], g[i][j]);
                }
            }
        }
    }
    public static void main(String[]args) throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] arr = in.readLine().split(" ");
        n = Integer.parseInt(arr[0]);
        m = Integer.parseInt(arr[1]);
        int k = Integer.parseInt(arr[2]);
		
        // 初始化
        for(int i=1; i<=n ;i++){
            for(int j=1; j<=n; j++){
                if(i==j) g[i][j]=0;
                else g[i][j] = max;
            }
        }

        for(int i=0; i<m; i++){
            String[] cur = in.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            int c = Integer.parseInt(cur[2]);

            g[a][b] = Math.min(c, g[a][b]);
        }

        floyd();

        for(int i=0; i<k; i++){
            String[] cur = in.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);

            if(g[a][b] >= max/2) {
                System.out.println("impossible");
            } else {
                System.out.println(g[a][b]);
            }
        }
    }
}
````

### 最小生成树

````java
无向图
    1.prim算法   O(n^2+m), n 表示点数，m 表示边数
        稀疏：朴素
        稠密：堆优化   一般不用
    如何区分稠密图？看n、m，相差不多那么就是稀疏图  m和n^2是一个级别那就是稠密图
    2.Kruskal算法 O(mlogm), n 表示点数，m 表示边数
    
    地图上有n个城市，知道n个城市坐标，称呼司之间铺设公路，相互连通，铺设公路总长度最小是多少。
````

### 朴素版prim算法

````java
/**
 * 858. Prim算法求最小生成树
 */
public class AC858 {
    static int N = 510;
    // 稠密图用邻接矩阵存储
    static int[][] g = new int[N][N];
    static int[] dist = new int[N];// 存储其他点到当前最小生成树的距离
    static boolean[] st = new boolean[N];
    static int max = (int)1e9;
    static int n; // n表示点数

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] arr = in.readLine().split(" ");
        n = Integer.parseInt(arr[0]);
        int m = Integer.parseInt(arr[1]);
        for(int i=1;i<=n;i++) {
            Arrays.fill(g[i],0x3f3f3f3f);
        }
        while(m-->0){
            String[] cur = in.readLine().split(" ");
            int u = Integer.parseInt(cur[0]);
            int v = Integer.parseInt(cur[1]);
            int w = Integer.parseInt(cur[2]);
            g[u][v] = g[v][u] = Math.min(g[u][v],w);
        }
        int t = prim();

        if(t==-1) {
            System.out.println("impossible");
        } else {
            System.out.println(t);
        }
    }

    static int prim() {
        Arrays.fill(dist,max);//初始化所有点到集合的距离都为正无穷
        int res = 0;//用于记录最小生成树的权值
        for (int i=0; i<n; i++) {
            //找到距离集合最近的那个点(不在集合当中的)
            int t = -1;
            for (int j=1; j<=n; j++) {
                if ((t==-1||dist[t]>dist[j]) && !st[j]) {
                    t = j;
                }
            }
            //如果此时不是寻找的第一个点，但是所有点到集合的距离最小值为正无穷，说明不存在最小生成树
            if (i>0 && dist[t] == max) {
                return -1;
            }
            if (i > 0) {
                res += dist[t];
            }
            // t加到距离最近的点中去
            st[t] = true;
            //用新加进来的点去更新其它点到集合的距离
            for (int j=1; j<=n; j++) {
                dist[j] = Math.min(dist[j], g[t][j]);
            }
        }
        return res;
    }
}
````

### Kruskal算法

````java
/**
 * 859. Kruskal算法求最小生成树
 * 稀疏图
 */
public class AC859 {

    static final int N = 100010;
    static int[] p = new int[N];// 并查集的父节点数组

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] val = br.readLine().split(" ");
        int n = Integer.parseInt(val[0]);
        int m = Integer.parseInt(val[1]);
        for (int i=1; i<=n; i++) {
            p[i] = i;
        }
        Edge[] edge = new Edge[m];

        for (int i=0; i<m; i++) {
            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            int c = Integer.parseInt(cur[2]);
            edge[i] = new Edge(a,b,c);
        }

        Arrays.sort(edge, new Comparator<Edge>() {
            @Override
            public int compare(Edge o1, Edge o2) {
                return o1.c- o2.c;
            }
        });
        int cnt = 0;
        int res = 0;
        for (int i=0; i<m; i++) {
            Edge temp = edge[i];
            int a = temp.a;
            int b = temp.b;
            int c = temp.c;
            a = find(a);
            b = find(b);
            if (a != b) {
                p[a] = b;
                res += c;
                cnt++;
            }
        }
        if (cnt == n-1) {
            System.out.println(res);
        } else {
            System.out.println("impossible");
        }
    }
    static int find(int x) {
        if (x!=p[x]) {
            p[x] = find(p[x]);
        }
        return p[x];
    }
}
````

### 二分图

````java
染色法：判别是不是二分图，  dfs  O(n+m), n 表示点数，m 表示边数
匈牙利算法：求二分图的最大匹配 O(nm), n 表示点数，m 表示边数
````

### 染色法

````java
/**
 * 860. 染色法判定二分图
 */
public class AC860 {

    static int n,m;
    static final int N = 100010;
    static final int M = 200010;
	// 领接表
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int idx;

    static int[] color = new int[N];// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String[] val = br.readLine().split(" ");
        n = Integer.parseInt(val[0]);
        m = Integer.parseInt(val[1]);

        Arrays.fill(h,-1);

        while (m-- != 0) {
            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            add(a,b);
            add(b,a);
        }

        boolean flag = true;
        // n个点进行染色
        for (int i=1; i<=n; i++) {
            if (color[i]==0) {
                // 第一个染1   然后用3-c巧妙的实现了一二交换 如果染色失败了 泽执行if里面的
                if (!dfs(i,1)) {
                    flag = false;
                    break;
                }
            }
        }

        if (flag) {
            System.out.println("Yes");
        } else {
            System.out.println("No");
        }

    }

    static boolean dfs(int u, int c) {
        // 从第一次这样染色
        color[u] = c;
        for (int i=h[u]; i!=-1; i=ne[i]) {
            int j = e[i];
            // 还没有呗染色
            if (color[j] == 0) {
                if (!dfs(j,3-c)) {
                    return false;
                }
            } else { // 如果已经染色 此时判断颜色是否相等
                if (color[j] == c) {
                    return false;
                }
            }
        }
        return true;
    }


    static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

}
````

### 匈牙利算法

````java
/**
 * 861. 二分图的最大匹配
 */
public class AC861 {

    static int n1; // n1表示第一个集合中的点数，n2表示第二个集合中的点数
    static int n2;
    static int m;
    static final int N = 510;
    static final int M = 100010;
    // 领接表
    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int idx;
    // 右面点对应的点
    static int[] match = new int[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
    static boolean[] st = new boolean[N]; // 表示第二个集合中的每个点是否已经被遍历过


    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String[] val = br.readLine().split(" ");
        n1 = Integer.parseInt(val[0]);
        n2 = Integer.parseInt(val[1]);
        m = Integer.parseInt(val[2]);

        Arrays.fill(h,-1);
        while (m-- != 0) {
            String[] cur = br.readLine().split(" ");
            int a = Integer.parseInt(cur[0]);
            int b = Integer.parseInt(cur[1]);
            add(a,b);
        }
        int res = 0;
        for (int i=1; i<=n1; i++) {
            Arrays.fill(st,false);
            if (find(i)) {
                res++;
            }
        }
        System.out.println(res);

    }

    static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;

    }

    static boolean find(int x) {

        for (int i=h[x]; i!=-1; i=ne[i]) {
            int j = e[i];
            if (!st[j]) {
                st[j] = true;
                if (match[j]==0 || find(match[j])) {
                    match[j] = x;
                    return true;
                }
            }
        }
        return false;
    }

}

````

